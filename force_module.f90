! -*- mode: F90; mode: font-lock; column-number-mode: true; vc-back-end: CVS -*-
! ------------------------------------------------------------------------------
! $Id$
! ------------------------------------------------------------------------------
! Module force_module
! ------------------------------------------------------------------------------
! Code area 7: moving atoms
! ------------------------------------------------------------------------------

!!****h* Conquest/force_module *
!!  NAME
!!   force_module
!!  PURPOSE
!!   Gathers together the force routines and variables
!!  USES
!!   atoms, blip_grid_transform_module, blip, calc_matrix_elements_module, common,
!!   datatypes, DiagModule, dimens, ewald_module, generic_blas, generic_comms, 
!!   global_module, grid_index, H_matrix_module, logicals, matrix_data, maxima_module, 
!!   multiply_module, mult_module, numbers, primary_module, pseudopotential_data, 
!!   set_bucket_module, S_matrix_module, species_module
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   12/06/2001 dave
!!  MODIFICATION HISTORY
!!   21/06/2001 dave
!!    Included matrix_diagonal
!!    Removed use matrix_diag in get_HF_non_local_force
!!    Removed matrix scaling from same
!!   13/05/2002 dave
!!    Added RCS id variable and TODO to get_HF_force - this needs fixing !
!!   29/05/2002 dave
!!    Added flag to check for ordern before getting K, also RCS static object and tweaked headers
!!   31/07/2002 dave
!!    Changed pulay_force to use data_M12 from matrix_data and not to pass it to get_support_gradient
!!   15:42, 08/04/2003 drb 
!!    Bug fixes (factor of 1/3 in XC, sign in nonSC), added nonSC forces and differential of GTH XC LDA 
!!    parameterisation
!!   14:20, 02/09/2003 drb 
!!    Added parameters to allow the non-local routine to find HF, phi Pulay or both.
!!   11:51, 30/09/2003 drb
!!    Mainly changes to correct non-SC forces
!!   10:09, 13/02/2006 drb 
!!    Removed all explicit references to data_ variables and rewrote in terms of new 
!!    matrix routines
!!   2008/02/06 08:14 dave
!!    Changed for output to file not stdout
!!  SOURCE
!!
module force_module

  use datatypes
  use global_module, ONLY: io_lun
  use timer_stdclocks_module, ONLY: start_timer,stop_timer,tmr_std_allocation,tmr_std_matrices

  implicit none
  save

  real(double), dimension(:,:), allocatable :: tot_force

  ! Useful parameters for selecting force calculations in NL part
  integer, parameter :: HF = 1
  integer, parameter :: Pulay = 2
  integer, parameter :: HF_and_Pulay = 3

  ! RCS tag for object file identification
  character(len=80), private :: RCSid = "$Id$"

!!***
contains

! ------------------------------------------------------------------------------
! Subroutine force
! ------------------------------------------------------------------------------

!!****f* force_module/force *
!!
!!  NAME 
!!   force
!!  USAGE
!! 
!!  PURPOSE
!!   Collects all force calculations in one place
!! 
!! ********************
!! ** IMPORTANT NOTE **
!! ********************
!!
!!   I know it shouldn't be like this, but it is: the order of the calls is VITAL ! pulay_force assumes that
!!   workspace_support contains h_on_support (as generated by get_H_matrix) so should be first (or should 
!!   regenerate h_on_support).  get_KE_force overwrites the on-site blocks of data_K with zeroes, and so should 
!!   LAST !
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   Sometime in 1998, I think
!!  MODIFICATION HISTORY
!!   15/05/2001 dave
!!    F90, indenting and ROBODoc
!!   21/05/2001 dave
!!    Reduced calls to get_HF_force and get_KE_force
!!    Reduced call to pulay_force
!!   22/05/2001 dave
!!    Bug fixes
!!    Shortened overall subroutine call and comments 
!!    before subroutine calls
!!   08/06/2001 dave
!!    Added GenComms for my_barrier and RCS Id and Log tags
!!   12/06/2001 dave
!!    Included in force_module
!!   13/05/2002 dave
!!    Tidied format statements
!!   11:52, 30/09/2003 drb 
!!    Added density_out variable to store output density for non-SC calculations and changed call to 
!!    get_nonSC_correction_force.  Also added call to get_electronic_density.  Also placed pulay_force call 
!!    FIRST (as it needs h_on_support in workspace_support).
!!  SOURCE
!!
  subroutine force(fixed_potential, vary_mu, n_cg_L_iterations, number_of_bands, tolerance, con_tolerance, mu,  &
       total_energy, expected_reduction, write_forces)

    use datatypes
    use numbers
    use units
    use ewald_module, ONLY: ewald_force
    use pseudopotential_data, ONLY: non_local
    use GenComms, ONLY: my_barrier, inode, ionode, cq_abort
 ! TM new pseudo
    use pseudopotential_common, ONLY: pseudo_type, OLDPS, SIESTA, STATE, ABINIT
    use pseudo_tm_module, ONLY: loc_pp_derivative_tm
    use global_module, ONLY: flag_self_consistent, flag_move_atom, id_glob, WhichPulay, BothPulay, PhiPulay, &
         flag_basis_set, PAOs, blips, ni_in_cell, iprint_MD, IPRINT_TIME_THRES2, area_moveatoms
    use density_module, ONLY: get_electronic_density, density
    use functions_on_grid,  ONLY: supportfns, H_on_supportfns
    use dimens, ONLY: n_my_grid_points
    use potential_module, ONLY: potential
    use maxima_module, ONLY: maxngrid
    use memory_module, ONLY: reg_alloc_mem, reg_dealloc_mem, type_dbl
    use timer_module

    implicit none

    ! Passed variables
    logical :: vary_mu, fixed_potential, write_forces

    integer :: n_cg_L_iterations

    real(double) :: number_of_bands, tolerance, con_tolerance, mu
    real(double) :: total_energy, expected_reduction

    ! Local variables (automatic arrays)
    real(double), dimension(:,:), allocatable :: p_force
    real(double), dimension(:,:), allocatable :: HF_force
    real(double), dimension(:,:), allocatable :: HF_NL_force
    real(double), dimension(:,:), allocatable :: KE_force
    real(double), dimension(:,:), allocatable :: nonSC_force
    real(double), dimension(:), allocatable :: density_out
    real(double) :: electrons, max_force
    integer :: i,j,ii, stat, max_atom, max_compt
    type(cq_timer) :: tmr_l_tmp1

    call start_timer(tmr_std_allocation)
    allocate(p_force(3,ni_in_cell),KE_force(3,ni_in_cell),HF_force(3,ni_in_cell),HF_NL_force(3,ni_in_cell),&
         nonSC_force(3,ni_in_cell),STAT=stat)
    if(stat/=0) call cq_abort("Error allocating forces: ",ni_in_cell)
    call reg_alloc_mem(area_moveatoms, 5*3*ni_in_cell,type_dbl)
    call stop_timer(tmr_std_allocation)
    ! The 'pulay force' is the force due to the change in energy caused
    ! by the change in the basis functions as the atoms move. 
    p_force = zero
    KE_force = zero
    HF_force = zero
    HF_NL_force = zero
    nonSC_force = zero
    tot_force = zero
    WhichPulay=BothPulay
    ! This ASSUMES that workspace_support contains h_on_support
    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    call pulay_force( p_force, fixed_potential, vary_mu, n_cg_L_iterations, &
         number_of_bands, tolerance, con_tolerance, mu, total_energy, &
         expected_reduction, ni_in_cell)
    call stop_print_timer(tmr_l_tmp1,"Pulay force",IPRINT_TIME_THRES2)
    ! Different forces depending on whether we're doing Harris-Foulkes or self-consistent
    if(.NOT.flag_self_consistent) then
       call start_timer(tmr_std_allocation)
       allocate(density_out(maxngrid), STAT=stat)
       if(stat/=0) call cq_abort("Error allocating output density: ",maxngrid)
       call stop_timer(tmr_std_allocation)
       call reg_alloc_mem(area_moveatoms, maxngrid,type_dbl)
       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       call get_electronic_density(density_out, electrons, supportfns, H_on_supportfns, &
            inode, ionode, maxngrid)
       call stop_print_timer(tmr_l_tmp1,"get_electronic_density",IPRINT_TIME_THRES2)
       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       call get_nonSC_correction_force( nonSC_force, potential, density_out, &
            inode, ionode, ni_in_cell, maxngrid)
       call stop_print_timer(tmr_l_tmp1,"NSC force",IPRINT_TIME_THRES2)
       ! Local HF force
       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       select case(pseudo_type)
       case(OLDPS)
          call get_HF_force( hf_force, density_out, ni_in_cell, maxngrid)
       case(SIESTA)
          call loc_pp_derivative_tm(hf_force, density_out, maxngrid)
       case(ABINIT)
          call loc_pp_derivative_tm(hf_force, density_out, maxngrid)
       end select
       call stop_print_timer(tmr_l_tmp1,"local pseudopotential force",IPRINT_TIME_THRES2)
       call start_timer(tmr_std_allocation)
       deallocate(density_out,STAT=stat)
       if(stat/=0) call cq_abort("Error deallocating output density: ",maxngrid)
       call reg_dealloc_mem(area_moveatoms, maxngrid,type_dbl)
       call stop_timer(tmr_std_allocation)
    else
       ! Local HF force
       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       select case(pseudo_type)
       case(OLDPS)
          call get_HF_force( hf_force, density, ni_in_cell, maxngrid)
       case(SIESTA)
          call loc_pp_derivative_tm(hf_force, density, maxngrid)
       case(ABINIT)
          call loc_pp_derivative_tm(hf_force, density, maxngrid)
       end select
       call stop_print_timer(tmr_l_tmp1,"local pseudopotential force",IPRINT_TIME_THRES2)
    end if

    ! This routine deals with the movement of the nonlocal pseudopotential.
    if (non_local) then
       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       call get_HF_non_local_force( HF_NL_force, HF_and_Pulay, ni_in_cell)
       call stop_print_timer(tmr_l_tmp1,"nonlocal pseudopotential force",IPRINT_TIME_THRES2)
    else
       HF_NL_force = 0.0_double
    end if

    ! Get the kinetic energy force component
    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    call get_KE_force( KE_force, ni_in_cell)
    call stop_print_timer(tmr_l_tmp1,"kinetic energy force",IPRINT_TIME_THRES2)
    max_force = 0.0_double
    if (inode==ionode.AND.write_forces) then
       write(io_lun,fmt='(/,20x,"Forces on atoms (",a2,"/",a2,")"/)') en_units(energy_units), d_units(dist_units)
       write(io_lun,fmt='(18x,"    Atom   X              Y              Z")')
    end if
    do i = 1, ni_in_cell
       do j=1,3
          if(flag_self_consistent) then
             tot_force(j,i) = HF_force(j,i)+HF_NL_force(j,i)+p_force(j,i) &
                  +KE_force(j,i)+ewald_force(j,i)
          else
             tot_force(j,i) = HF_force(j,i)+HF_NL_force(j,i)+p_force(j,i) &
                  +KE_force(j,i)+ewald_force(j,i)+nonSC_force(j,i)
          end if
          if(.NOT.flag_move_atom(j,i)) then 
             tot_force(j,i) = 0.0_double
          end if
          if(abs(tot_force(j,i))>max_force) then
             max_force = abs(tot_force(j,i))
             max_atom = i
             max_compt = j
          end if
       enddo
       if (inode==ionode) then
          if(iprint_MD>2) then
             write(io_lun,101) i
             write(io_lun,102) (for_conv*HF_force(j,i),j=1,3)
             write(io_lun,112) (for_conv*HF_NL_force(j,i),j=1,3)
             write(io_lun,103) (for_conv*p_force(j,i),j=1,3)
             write(io_lun,104) (for_conv*KE_force(j,i),j=1,3)
             write(io_lun,106) (for_conv*ewald_force(j,i),j=1,3)
             if(flag_self_consistent) then
                write(io_lun,105) (for_conv*tot_force(j,i),j=1,3)
             else
                write(io_lun,107) (for_conv*nonSC_force(j,i),j=1,3)
                write(io_lun,105) (for_conv*tot_force(j,i),j=1,3)
             end if
          else if(write_forces) then
             if(flag_self_consistent) then
                write(io_lun,fmt='(20x,i6,3f15.10)') i,(for_conv*tot_force(j,i),j=1,3)
             else
                write(io_lun,fmt='(20x,i6,3f15.10)') i,(for_conv*tot_force(j,i),j=1,3)
             end if
          end if
       end if
    enddo
    call my_barrier()
    if(inode==ionode) &
         write(io_lun,fmt='(4x,"Maximum force : ",f15.8,"(",a2,"/",a2,") on atom, component ",2i9)') &
         for_conv*max_force, en_units(energy_units), d_units(dist_units), max_atom, max_compt
    if(inode==ionode.AND.iprint_MD>1.AND.write_forces) write(io_lun,fmt='(4x,"Finished force")')
    call start_timer(tmr_std_allocation)
    deallocate(p_force,KE_force,HF_force,HF_NL_force, nonSC_force,STAT=stat)
    if(stat/=0) call cq_abort("Error deallocating forces: ",ni_in_cell)
    call reg_dealloc_mem(area_moveatoms, 5*3*ni_in_cell,type_dbl)
    call stop_timer(tmr_std_allocation)
    return
101 format('Force on atom ',i9)
102 format('Force H-F  : ',3f15.10)
112 format('Force H-Fnl: ',3f15.10)
103 format('Force pulay: ',3f15.10)
104 format('Force KE   : ',3f15.10)
106 format('Force Ewald: ',3f15.10)
107 format('Force nonSC: ',3f15.10)
105 format('Force Total: ',3f15.10)
  end subroutine force
!!***

! -----------------------------------------------------------
! Subroutine pulay_force
! -----------------------------------------------------------

!!****f* force_module/pulay_force *
!!
!!  NAME 
!!   pulay_force
!!  USAGE
!! 
!!  PURPOSE
!!   Evaluates the Pulay contribution to the forces on
!!   the atoms. This is the change in energy due to
!!   the movement of the blip functions causing a change in support
!!   function. The change in energy wrt blip functions is zero (variational)
!!   but the change in energy wrt the variation of a given support function
!!   at a given point is not in general zero. If the atom moves, all the
!!   blip functions associated with it move, and there is a corresponding
!!   change in the values of the support functions. The gradient of the
!!   support functions wrt movement of the atoms with which they are
!!   associated is held in gradsupport. This need to be integrated with
!!   the gradient of energy wrt change in support functions, which is
!!   given by the subroutine get_support_gradient.
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   C.M.Goringe
!!  CREATION DATE
!!   13/09/95
!!  MODIFICATION HISTORY
!!   24/4/96 Chris Goringe
!!    We have changed the data format, and these changes are required to 
!!    deal with it. blip_to_gradsupport is now replaced by the general
!!    blip_transform routine
!!
!!   24/2/97 Chris Goringe
!!    Quite a lot of other changes have occured in the code, in particular
!!    we no longer ever get the grad of the support functions; we just
!!    get it one component at a time.
!!  
!!    workspace_support  is used to hold the gradient of energy wrt
!!                       support functions
!!    workspace2_support is used to hold gradient of support functions
!!                       with respect to atomi position
!!   17/5/97 DRB to implement HeadGordon
!!   02/02/2001 TM
!!    blip_to_support_new, get_matrix_elements_new, blip_to_grad_new
!!   16/05/2001 dave
!!    F90 format, ROBODoc, new blip_to_grad call
!!   18/05/2001 dave
!!    Fixed the get_H_matrix call
!!   22/05/2001 dave
!!    Stripped subroutine call
!!   23/05/2001 dave
!!    Various small fixes
!!   12/06/2001 dave
!!    Included in force_module
!!   29/05/2002 dave
!!    Added flag from DiagModule so that K isn't made if we're diagonalising
!!   31/07/2002 dave
!!    Changed to use data_M12 from matrix_data and changed call to get_support_gradient to remove data_M12
!!   14:49, 2003/06/09 dave
!!    Added use statement for blip_gradient (get_support_gradient moved)
!!   08:06, 2003/10/01 dave
!!    Added basic structure for PAO basis set
!!  SOURCE
!!
  subroutine pulay_force( p_force, fixed_potential, vary_mu, n_cg_L_iterations, &
       number_of_bands, L_tol, self_tol, mu, total_energy, expected_reduction, n_atoms)

    use datatypes
    use logicals
    use numbers
    use primary_module, ONLY: bundle
    use matrix_module, ONLY: matrix, matrix_halo
    use matrix_data, ONLY: mat, Srange, halo
    use mult_module, ONLY: LNV_matrix_multiply, matM12, allocate_temp_matrix, free_temp_matrix, &
         return_matrix_value, matrix_pos, scale_matrix_value
    use global_module, ONLY: iprint_MD, WhichPulay, BothPulay, PhiPulay, SPulay, flag_basis_set, blips, PAOs, sf, &
         flag_onsite_blip_ana
    use set_bucket_module, ONLY: rem_bucket, sf_sf_rem
    use blip_grid_transform_module, ONLY: blip_to_support_new, &
         blip_to_grad_new
    use calc_matrix_elements_module, ONLY: get_matrix_elements_new
    use S_matrix_module, ONLY: get_S_matrix
    use H_matrix_module, ONLY: get_H_matrix
    use GenComms, ONLY: gsum, cq_abort, mtime, inode, ionode
    use DiagModule, ONLY: diagon
    use blip_gradient, ONLY: get_support_gradient
    use PAO_grid_transform_module, ONLY: PAO_to_grad
    use build_PAO_matrices, ONLY: assemble_deriv_2
    use cover_module, ONLY: BCS_parts
    use functions_on_grid, ONLY: supportfns, H_on_supportfns, allocate_temp_fn_on_grid, free_temp_fn_on_grid
    use species_module, ONLY: nsf_species
! Temp
    use dimens, ONLY: grid_point_volume, n_my_grid_points
    use density_module, ONLY: get_electronic_density, density
    use maxima_module, ONLY: maxngrid

    implicit none

    ! Passed variables
    logical :: vary_mu, fixed_potential

    integer :: n_atoms
    integer :: n_cg_L_iterations

    real(double) :: number_of_bands, mu, L_tol, self_tol
    real(double) :: total_energy,expected_reduction
    real(double), dimension(3,n_atoms) :: p_force

    ! Local variables
    logical :: test

    integer :: direction, count, nb, na, nsf1, point, place, i, neigh, ist,wheremat, jsf, gcspart, tmp_fn, n1, n2, this_nsf

    real(double) :: electrons, energy_in, t0, t1

    ! Workarray for New Version
    !    I am not sure the present way for calculating p_force is the right way.
    !   Now, we calculate matrix elements data_tmp (= Sum_l phi_ialpha(rl)
    !   * psi_jbeta(rl)), whose off-diagonal elements are not needed.
    !   Then, calculate p_force from summing up diagonal elements of data_tmp.
    !    In the old version, every processor has to communicate with all other
    !   processors. The communication in the new version is local, but
    !   it calculates unneeded off-diagonal elements. Similar situation
    !   occurs in the normalisation of support functions at (initial_phis.f90)
    !    I am planning to implement the subroutine which only calculates
    !   the diagonal elements of matrix (=Sum_l phi_ialpha(rl) * psi_ialpha(rl))
    !   with local communication. (I am not sure it is important or not)
    !    --  02/Feb/2001  Tsuyoshi Miyazaki

    integer :: iprim,np,ni,isf,mat_tmp

    ! the force due to the change in T matrix elements is done differently...
    mat_tmp = allocate_temp_matrix(Srange,0)
    if(inode==ionode.AND.iprint_MD>2) write(io_lun,fmt='(4x,"Starting pulay_force()")')
    p_force = zero

    ! first, lets make sure we have everything up to date. 
    ! Update H will give us support, S, K, H
    ! and h(local)_on_support [in workspace_support]

    ! This should be checked and changed: we don't want to do all this 
    ! again if we can avoid it !  Probably we will (a) have the data 
    ! already, or can (b) try get_SC_potl/get_new_rho or even just 
    ! get_H_matrix...
    test = .false.
    if(test) then
       ! (1) get S matrix

       call get_S_matrix(inode, ionode)

       ! (2) get K matrix

       if(.NOT.diagon) call LNV_matrix_multiply(electrons, total_energy, &
            doK, dontM1, dontM2, dontM3, dontM4, dontphi, dontE,0,0,0,0 )
       ! (3) get H matrix (and find new potential)
       call get_electronic_density(density, electrons, supportfns, H_on_supportfns, inode, ionode,maxngrid)
       call get_H_matrix(.false., fixed_potential, electrons, density, maxngrid)
! Moved inside if 15:16, 15/10/2002 drb 
       ! for the energy wrt support function we need  M1 and M2...
       ! If we're diagonalising, we've already build data_M12
       if(.NOT.diagon) call LNV_matrix_multiply(electrons, energy_in, &
            dontK, doM1, doM2, dontM3, dontM4, dontphi, dontE, matM12,0,0,0)
    endif

    t0 = mtime()
    ! for the energy wrt support function we need  M1 and M2...
    ! If we're diagonalising, we've already build data_M12
    if(.NOT.diagon) call LNV_matrix_multiply(electrons, energy_in, &
         dontK, doM1, doM2, dontM3, dontM4, dontphi, dontE, matM12,0,0,0)
    t1 = mtime()
    t0 = t1
    ! N.B. IT IS VITAL TO HAVE h_on_support in workspace_support !
    ! now we can evaluate support_gradient (into workspace_support)
    ! If we are doing analytic on-site integrals, then zero the elements of M12 (the energy matrix) first
    if(flag_basis_set==blips.AND.flag_onsite_blip_ana) then
       iprim = 0
       do np = 1, bundle%groups_on_node
          do ni = 1,bundle%nm_nodgroup(np)
             iprim = iprim+1
             this_nsf = nsf_species(bundle%species(iprim))
             do n1 = 1,this_nsf
                do n2 = 1,this_nsf
                   call scale_matrix_value(matM12,np,ni,iprim,0,n1,n2,zero,1)
                end do
             end do
          enddo
       end do
    end if
    call get_support_gradient(inode, ionode)
    t1 = mtime()
    if(inode==ionode.AND.iprint_MD>3) write(io_lun,fmt='(4x,"get_support_gradient time: ",f12.5)') t1-t0
    t0 = t1


    if(WhichPulay==BothPulay.OR.WhichPulay==PhiPulay.OR.(WhichPulay==SPulay.AND.flag_basis_set==blips)) then
       tmp_fn = allocate_temp_fn_on_grid(sf)
       ! now for each direction in turn
       do direction = 1, 3

          ! we get the grad of the support functions
          if(flag_basis_set==blips) then
             call blip_to_grad_new(inode-1, direction, tmp_fn)
          else if(flag_basis_set==PAOs) then
             call PAO_to_grad(inode-1,direction,tmp_fn)
          else
             call cq_abort("pulay_force: basis set undefined ",flag_basis_set)
          end if
          t1 = mtime()
          if(inode==ionode.AND.iprint_MD>3) write(io_lun,fmt='(10x,"Phi Pulay grad ",i4," time: ",f12.5)') direction,t1-t0
          t0 = t1


          !       ! and do the integration
          !       count = 0
          !       ! loop over all grid points
          !       do nb = 1, n_blocks
          !       ! loop over support regions on this grid point
          !          do na = 1, n_atoms_block(nb)
          !             i = atoms_block(nb, na)
          !             ! loop over support functions
          !             do nsf1 = 1, nsf
          !                ! loop over points in block
          !                do point = 1, n_pts_in_block
          !                   place = count + point
          !                   p_force(direction,i) = p_force(direction,i) - &
          !                        workspace_support(place) * &
          !                        workspace2_support(place) * &
          !                        grid_point_volume
          !                end do
          !                count = count + n_pts_in_block
          !             end do
          !          end do
          !       end do
          !    end do
          !    !sum contributions from all nodes
          !    call gsum(p_force,3,n_atoms)

          call get_matrix_elements_new(inode-1,rem_bucket(sf_sf_rem),mat_tmp, H_on_supportfns, tmp_fn)
          t1 = mtime()
          if(inode==ionode.AND.iprint_MD>3) write(io_lun,fmt='(10x,"Phi Pulay int ",i4," time: ",f12.5)') direction,t1-t0
          t0 = t1

          iprim=0
          call start_timer(tmr_std_matrices)
          do np=1,bundle%groups_on_node
             if(bundle%nm_nodgroup(np) > 0) then
                do ni=1,bundle%nm_nodgroup(np)
                   iprim=iprim+1
                   !i=id_glob(index_my_atoms(iprim))
                   !i=index_my_atoms(iprim)
                   i=bundle%ig_prim(iprim)
                   do isf=1,nsf_species(bundle%species(iprim))
                      p_force(direction,i)=p_force(direction,i)- &
                           return_matrix_value(mat_tmp,np,ni,0,0,isf,isf,1)
                      ! The factor of grid_point_volume is already included
                      ! in get_matrix_elements
                   enddo ! isf
                enddo ! ni
             endif ! if the partition has atoms
          enddo ! np
          call stop_timer(tmr_std_matrices)
          t1 = mtime()
          if(inode==ionode.AND.iprint_MD>3) write(io_lun,fmt='(10x,"Phi Pulay sum ",i4," time: ",f12.5)') direction,t1-t0
          t0 = t1

       enddo ! direction
       call free_temp_fn_on_grid(tmp_fn)
    end if! if(WhichPulay==BothPulay.OR.WhichPulay==PhiPulay)
    if(flag_basis_set==PAOs.AND.(WhichPulay==BothPulay.OR.WhichPulay==SPulay)) then ! We need to do the S-pulay term
       ! now for each direction in turn
       do direction = 1, 3
          ! Call assemble to generate dS_ij/dR_kl
          call assemble_deriv_2(direction,Srange, mat_tmp,1)
          ! For each primary set atom, we want \sum_j dS_ij G_ij (I think)
          iprim=0
          call start_timer(tmr_std_matrices)
          do np=1,bundle%groups_on_node
             if(bundle%nm_nodgroup(np) > 0) then
                do ni=1,bundle%nm_nodgroup(np)
                   iprim=iprim+1
                   !i=id_glob(index_my_atoms(iprim))
                   !i=index_my_atoms(iprim)
                   i=bundle%ig_prim(iprim)
                   do neigh = 1,mat(np,Srange)%n_nab(ni)
                      ist = mat(np,Srange)%i_acc(ni)+neigh-1
                      gcspart = BCS_parts%icover_ibeg(mat(np,Srange)%i_part(ist))+mat(np,Srange)%i_seq(ist)-1
                      wheremat = matrix_pos(matM12,iprim,halo(Srange)%i_halo(gcspart),1,1)
                      if(wheremat/=mat(np,Srange)%onsite(ni)) then
                         do isf=1,mat(np,Srange)%ndimj(ist)
                            do jsf=1,mat(np,Srange)%ndimi(ni)
                               p_force(direction,i)=p_force(direction,i)+ &
                                    four*return_matrix_value(mat_tmp,np,ni,iprim,neigh,jsf,isf)* &
                                    return_matrix_value(matM12,np,ni,iprim,neigh,jsf,isf)
                               !four*return_matrix_value_pos(mat_tmp,wheremat+jsf-1+(isf-1)*nsf)*&
                               !     return_matrix_value_pos(matM12,wheremat+jsf-1+(isf-1)*nsf)
                            end do
                         end do
                      end if
                   end do
                end do
             end if
          end do
          call stop_timer(tmr_std_matrices)
          t1 = mtime()
          if(inode==ionode.AND.iprint_MD>3) write(io_lun,*) 'S Pulay ',direction,' time: ',t1-t0
          t0 = t1
       end do ! direction
    end if

    !  In principle, the summation below is not needed.
    !  p_force should be calculated only for my primary set of atoms.
    call gsum(p_force,3,n_atoms)
    call free_temp_matrix(mat_tmp)
    return
  end subroutine pulay_force
!!***

! -----------------------------------------------------------
! Subroutine get_HF_force
! -----------------------------------------------------------

!!****f* force_module/get_HF_force *
!!
!!  NAME 
!!   get_HF_force
!!  USAGE
!! 
!!  PURPOSE
!!   Gets the Hellman-Feynman contribution to the 
!!   atomic forces. For this both the electron density
!!   and Hartree potential are needed.
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   E.H.Hernandez
!!  CREATION DATE
!!   Summer 1995
!!  MODIFICATION HISTORY
!!   12/9/95 by Chris Goringe to use new data distribution
!!   22/1/96 by EH to correct.
!!   24/4/96 by EH to adapt to new data structure.
!!   27/11/97 by DRB to correct expressions
!!   21/05/2001 dave
!!    Added ROBODoc header, converted to F90 and stripped
!!    subroutine calls
!!   08/06/2001 dave
!!    Changed to use gsum from GenComms and added RCS Id
!!    and Log tags
!!   12/06/2001 dave
!!    Included in force_module
!!   2004/10/05 drb
!!    Added hartree_module use
!!   2008/03/03 18:46 dave
!!    Changed float to real
!!  TODO
!!    Fix this so that it doesn't loop over all processors ! Follow set_pseudo 13/05/2002 dave
!!  SOURCE
!!
  subroutine get_HF_force( hf_force, density, n_atoms, size)

    use datatypes
    use numbers
    use dimens, ONLY: n_my_grid_points, x_grid, y_grid, z_grid, &
         grid_point_volume, r_super_x, r_super_y, r_super_z
    use grid_index, ONLY: grid_point_block, grid_point_x, grid_point_y, &
         grid_point_z
    use species_module, ONLY: species, charge
    use pseudopotential_data, ONLY: ps_exponent, core_radius_2, radius_max, &
         n_points_max, local_pseudopotential, d2_local_pseudopotential
    use global_module, ONLY: rcellx,rcelly,rcellz,id_glob, species_glob, nlpf, ni_in_cell
    use block_module, ONLY : nx_in_block,ny_in_block,nz_in_block, &
         n_pts_in_block
    use group_module, ONLY : blocks, parts
    use primary_module, ONLY: domain
    use cover_module, ONLY: DCS_parts
    use set_blipgrid_module, ONLY : naba_atm
    use GenComms, ONLY: my_barrier, cq_abort, inode, ionode, gsum
    use hartree_module, ONLY: hartree
    use maxima_module, ONLY: maxngrid

    implicit none

    ! Passed variables
    integer :: n_atoms, size

    real(double) :: hf_force( 3, n_atoms ), density( size )


    ! Local variables
    integer :: i, j, my_block, n, the_species, iatom

    real(double) :: a, b, da, db, dc, dd, r, alpha, beta,  &
         derivative, fx_1, fx_2, fy_1, fy_2, fz_1, fz_2, &
         gauss, h_energy, rx, ry, rz, x_point, y_point, z_point, &
         r2, r_from_i, x, y, z, step, q, elec_here, local_potential, c, d

    real(double):: dcellx_block,dcelly_block,dcellz_block
    real(double):: dcellx_grid, dcelly_grid, dcellz_grid
    integer :: ipart,jpart,ind_part,ia,ii,icover,ig_atom
    real(double):: xatom,yatom,zatom
    real(double):: xblock,yblock,zblock
    real(double) :: dx,dy,dz
    integer :: ix,iy,iz,iblock,ipoint,igrid

    ! Automatic
    real(double) :: h_potential( size ) 

    HF_force = 0

!    the_species = 1
!    step = radius_max(1)/real(n_points_max(1)-1,double)
!    do i=1,n_points_max(1)-1
!       r = i*step+0.5*step
!       a = ( real(i+1,double)*step - r ) / step
!       b = one - a
!       c = a * ( a * a - one ) * step * step / six
!       d = b * ( b * b - one ) * step * step / six
!       da = -one / step
!       db =  one / step
!       dc = -step * ( three * a * a - one ) / six
!       dd =  step * ( three * b * b - one ) / six
!       local_potential =   &
!            a * local_pseudopotential(i,the_species)+  &
!            b * local_pseudopotential(i+1,the_species)+ &
!            c * d2_local_pseudopotential(i,the_species)+  &
!            d * d2_local_pseudopotential(i+1,the_species)
!       derivative =  &
!            da * local_pseudopotential(i,the_species) +  &
!            db * local_pseudopotential(i+1,the_species) + &
!            dc * d2_local_pseudopotential(i,the_species) +  &
!            dd * d2_local_pseudopotential(i+1,the_species)
!    enddo
    ! get Hartree potential
    call hartree( density, h_potential, maxngrid, h_energy )

    dcellx_block=rcellx/blocks%ngcellx; dcellx_grid=dcellx_block/nx_in_block
    dcelly_block=rcelly/blocks%ngcelly; dcelly_grid=dcelly_block/ny_in_block
    dcellz_block=rcellz/blocks%ngcellz; dcellz_grid=dcellz_block/nz_in_block
    call my_barrier()


    do iblock = 1, domain%groups_on_node ! primary set of blocks
       xblock=(domain%idisp_primx(iblock)+domain%nx_origin-1)*dcellx_block
       yblock=(domain%idisp_primy(iblock)+domain%ny_origin-1)*dcelly_block
       zblock=(domain%idisp_primz(iblock)+domain%nz_origin-1)*dcellz_block
       if(naba_atm(nlpf)%no_of_part(iblock) > 0) then ! if there are naba atoms
          iatom=0
          do ipart=1,naba_atm(nlpf)%no_of_part(iblock)
             jpart=naba_atm(nlpf)%list_part(ipart,iblock)
             if(jpart > DCS_parts%mx_gcover) then 
                call cq_abort('set_ps: JPART ERROR ',ipart,jpart)
             endif
             ind_part=DCS_parts%lab_cell(jpart)
             do ia=1,naba_atm(nlpf)%no_atom_on_part(ipart,iblock)
                iatom=iatom+1
                ii = naba_atm(nlpf)%list_atom(iatom,iblock)
                icover= DCS_parts%icover_ibeg(jpart)+ii-1
                ig_atom= id_glob(parts%icell_beg(ind_part)+ii-1)
                if(parts%icell_beg(ind_part) + ii-1 > ni_in_cell) then
                   call cq_abort('set_ps: globID ERROR ', &
                        ii,parts%icell_beg(ind_part))
                endif
                if(icover > DCS_parts%mx_mcover) then
                   call cq_abort('set_ps: icover ERROR ', &
                        icover,DCS_parts%mx_mcover)
                endif
                xatom=DCS_parts%xcover(icover)
                yatom=DCS_parts%ycover(icover)
                zatom=DCS_parts%zcover(icover)
                !the_species=species(ig_atom)
                the_species = species_glob(ig_atom)
                q =charge(the_species)
                alpha = ps_exponent(the_species)
                beta = (alpha / pi)**1.5_double * grid_point_volume
                step = radius_max(the_species)/real(n_points_max(the_species)-1,double)
                ipoint=0
                do iz=1,nz_in_block
                   do iy=1,ny_in_block
                      do ix=1,nx_in_block
                         ipoint=ipoint+1
                         igrid=n_pts_in_block*(iblock-1)+ipoint
                         if(igrid > n_my_grid_points) then
                            call cq_abort('set_ps: igrid error ', &
                                 igrid, n_my_grid_points)
                         endif
                         elec_here = density(igrid) * grid_point_volume
                         dx=dcellx_grid*(ix-1)
                         dy=dcelly_grid*(iy-1)
                         dz=dcellz_grid*(iz-1)
                         rx=xblock+dx-xatom
                         ry=yblock+dy-yatom
                         rz=zblock+dz-zatom
                         r2 = rx * rx + ry * ry + rz * rz
                         gauss = exp( -alpha * r2 )
                         if(r2 < core_radius_2(the_species)) then
                            r_from_i = sqrt( r2 )
                            !if ( r_from_i > zero ) then
                            if ( r_from_i > very_small ) then
                               x = rx / r_from_i
                               y = ry / r_from_i
                               z = rz / r_from_i
                            else
                               x = zero
                               y = zero
                               z = zero
                            end if
                            j = aint( r_from_i / step ) + 1
                            ! check j
                            if(j > n_points_max(the_species)-1) then
                               call cq_abort('set_ps: overrun problem',j)
                            endif
                            r = real(j,double) * step
                            a = ( r - r_from_i ) / step
                            b = one - a
                            da = -one / step
                            db =  one / step
                            dc = -step * ( three * a * a - one ) / six
                            dd =  step * ( three * b * b - one ) / six
                            derivative =  &
                                 da * local_pseudopotential(j,the_species) +  &
                                 db * local_pseudopotential(j+1,the_species) + &
                                 dc * d2_local_pseudopotential(j,the_species) +  &
                                 dd * d2_local_pseudopotential(j+1,the_species)

                            ! This is a little obscure, but the multiples below have had 
                            ! the minus sign which should be there removed to correct an 
                            ! earlier on dropped in the da, db, dc, dd expressions.DRB 27.11.97
                            fx_1 = x * derivative
                            fy_1 = y * derivative 
                            fz_1 = z * derivative 
                            fx_2 = two * alpha * beta * rx * gauss * h_potential( igrid ) * q
                            fy_2 = two * alpha * beta * ry * gauss * h_potential( igrid ) * q
                            fz_2 = two * alpha * beta * rz * gauss * h_potential( igrid ) * q
                         else
                            fx_1 = zero
                            fy_1 = zero
                            fz_1 = zero
                            fx_2 = zero
                            fy_2 = zero
                            fz_2 = zero
                         end if
                         HF_force(1,ig_atom) = HF_force(1,ig_atom) + fx_1 * elec_here 
                         HF_force(2,ig_atom) = HF_force(2,ig_atom) + fy_1 * elec_here
                         HF_force(3,ig_atom) = HF_force(3,ig_atom) + fz_1 * elec_here
                         HF_force(1,ig_atom) = HF_force(1,ig_atom) + fx_2
                         HF_force(2,ig_atom) = HF_force(2,ig_atom) + fy_2
                         HF_force(3,ig_atom) = HF_force(3,ig_atom) + fz_2
                      enddo !ix
                   enddo  !iy
                enddo   !iz
             enddo ! naba_atoms
          enddo ! naba_part
       endif !(naba_atm(nlpf)%no_of_part(iblock) > 0) !naba atoms?
    enddo ! iblock : primary set of blocks


!    ! now loop over grid points and accumulate HF part of the force
!    do n=1, n_my_grid_points
!       my_block = grid_point_block(n)
!       elec_here = density(n) * grid_point_volume
!       x_point = (grid_point_x(n) - 1) * x_grid
!       y_point = (grid_point_y(n) - 1) * y_grid
!       z_point = (grid_point_z(n) - 1) * z_grid
!       do i=1, n_atoms
!          q = charge(species(i))
!          alpha = exponent(species(i))
!          beta = (alpha / pi)**1.5_double * grid_point_volume
!          rx = ( x_point - rionx(i) ) 
!          ry = ( y_point - riony(i) )
!          rz = ( z_point - rionz(i) )
!          rx = rx - anint(rx)
!          ry = ry - anint(ry)
!          rz = rz - anint(rz)
!          rx = rx * r_super_x
!          ry = ry * r_super_y
!          rz = rz * r_super_z
!          r2 = rx * rx + ry * ry + rz * rz
!          gauss = dexp( -alpha * r2 )
!          if ( r2 .lt. core_radius_2(species(i)) ) then
!             r_from_i = sqrt( r2 )
!             if ( r_from_i .gt. zero ) then
!                x = rx / r_from_i
!                y = ry / r_from_i
!                z = rz / r_from_i
!             else
!                x = zero
!                y = zero
!                z = zero
!             end if
!             ! now we construct the derivative of the local part of the 
!             ! pseudopotential by spline interpolation from a table
!             step = radius_max(species(i)) / &
!                  real( n_points_max(species(i)) - 1, double)
!             j = aint( r_from_i / step ) + 1
!
!             ! with this we can now use the spline interpolation tables to 
!             ! construct the derivative of the local part of the 
!             ! pseudopotential on the grid
!             r = real(j,double) * step
!             a = ( r - r_from_i ) / step
!             b = one - a
!             da = -one / step
!             db =  one / step
!             dc = -step * ( three * a * a - one ) / six
!             dd =  step * ( three * b * b - one ) / six
!             derivative =  &
!                  da * local_pseudopotential(j,species(i)) +  &
!                  db * local_pseudopotential(j+1,species(i)) + &
!                  dc * d2_local_pseudopotential(j,species(i)) +  &
!                  dd * d2_local_pseudopotential(j+1,species(i))
!
!             ! This is a little obscure, but the multiples below have had 
!             ! the minus sign which should be there removed to correct an 
!             ! earlier on dropped in the da, db, dc, dd expressions.DRB 27.11.97
!             fx_1 = x * derivative
!             fy_1 = y * derivative 
!             fz_1 = z * derivative 
!             fx_2 = two * alpha * beta * rx * gauss * h_potential( n ) * q
!             fy_2 = two * alpha * beta * ry * gauss * h_potential( n ) * q
!             fz_2 = two * alpha * beta * rz * gauss * h_potential( n ) * q
!          else
!             fx_1 = zero
!             fy_1 = zero
!             fz_1 = zero
!             fx_2 = zero
!             fy_2 = zero
!             fz_2 = zero
!          end if
!          HF_force(1,i) = HF_force(1,i) + fx_1 * elec_here 
!          HF_force(2,i) = HF_force(2,i) + fy_1 * elec_here
!          HF_force(3,i) = HF_force(3,i) + fz_1 * elec_here
!!            fx_2 = two * alpha * beta * rx * gauss * h_potential( n ) * q
!!            fy_2 = two * alpha * beta * ry * gauss * h_potential( n ) * q
!!            fz_2 = two * alpha * beta * rz * gauss * h_potential( n ) * q
!          HF_force(1,i) = HF_force(1,i) + fx_2
!          HF_force(2,i) = HF_force(2,i) + fy_2
!          HF_force(3,i) = HF_force(3,i) + fz_2
!       end do
!    end do

    ! and add contributions from all nodes
!    do i = 1, n_atoms
!       write(io_lun,*) inode,i,(HF_force(j,i),j=1,3)
!    enddo
    call gsum(HF_force,3,n_atoms)
!    do i = 1, n_atoms
!       write(io_lun,*) inode,i,(HF_force(j,i),j=1,3)
!    enddo
    return    
  end subroutine get_HF_force
!!***

! -----------------------------------------------------------
! Subroutine get_HF_non_local_force
! -----------------------------------------------------------

!!****f* force_module/get_HF_non_local_force *
!!
!!  NAME 
!!   get_HF_non_local_force
!!  USAGE
!! 
!!  PURPOSE
!!   Gets the non-local part of the HF force
!! 
!!   There is a little wrangling about this - it's not entirely clear
!!   whether it's a Hellmann-Feynman force or a Pulay force. Whatever 
!!   it's called, it is due to the change in the support/projector 
!!   overlap matrix with no dependence on the charge density.
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   E.H.Hernandez
!!  CREATION DATE
!!   29/4/96 
!!  MODIFICATION HISTORY
!!   24/2/97 CMG 
!!    We no longer carry grad support around, it needs to be generated on the fly
!!   04/09/2000 TM
!!    new get_matrix_elements  
!!   15/01/2001 TM
!!    new blip_to_grad  
!!   11/05/01 and 14/05/01 DRB
!!    Removed many of the arguments passed and redundant local variables
!!   17/05/2001 dave
!!    Changed subroutine call to blip_to_grad
!!   21/05/2001 dave
!!    Reduced subroutine call and use statements
!!   22/05/2001 dave
!!    Added more discussion to the PURPOSE comment field
!!   11/06/2001 dave
!!    Added RCS Id and Log tags and GenComms
!!   11/06/2001 dave
!!    Corrected to add data_U finding lines (required for correct forces)
!!   12/06/2001 dave
!!    Included in force_module
!!   21/06/2001 dave
!!    Removed use matrix_diag (now in this module)
!!    Removed matrix_scaling
!!   14:20, 02/09/2003 drb 
!!    Added flag to select HF or Pulay or both (for easier force testing)
!!   08:12, 2003/10/01 dave
!!    Added structure to prepare for PAO basis set
!!  SOURCE
!!
  subroutine get_HF_non_local_force(HF_NL_force, what_force, n_atoms)

    use datatypes
    use numbers
    use matrix_data, ONLY: SPrange, PSrange
    use mult_module, ONLY: SP_trans, mult, H_SP_SP, matrix_product, matrix_scale, matrix_transpose, &
         allocate_temp_matrix, free_temp_matrix, matU, matUT, matCS, matSC, matK
    use dimens
    use species_module, ONLY: species
    use GenBlas
    use pseudopotential_data, ONLY: pseudopotential_derivatives

    use set_bucket_module, ONLY: rem_bucket, sf_nlpf_rem
    use calc_matrix_elements_module, ONLY: get_matrix_elements_new
    use blip_grid_transform_module, ONLY: blip_to_grad_new
    use GenComms, ONLY: gsum, cq_abort, inode, ionode
 ! TM new pseudo
    use pseudopotential_common, ONLY: pseudo_type, OLDPS, SIESTA, STATE, ABINIT
    use pseudo_tm_module, ONLY: nonloc_pp_derivative_tm
    use global_module, ONLY: iprint_MD, flag_basis_set, blips, PAOs, sf, nlpf
! TEMP
    use PAO_grid_transform_module, ONLY: PAO_to_grad
    use build_PAO_matrices, ONLY: assemble_deriv_2
    use group_module, ONLY: parts
    use primary_module, ONLY: bundle
    use cover_module, ONLY: BCS_parts
    use GenComms, ONLY: gsum, myid

    use functions_on_grid, ONLY: allocate_temp_fn_on_grid, free_temp_fn_on_grid, &
         supportfns, H_on_supportfns,pseudofns

    implicit none

    ! Passed variables
    integer :: n_atoms
    integer :: what_force

    real(double) :: HF_NL_force( 3, n_atoms )

    ! Local variables

    ! data_dCS will be obtained by a global trans of data_dCS_t
    !  this trans is same as the one used in U => UT
    !     Tsuyoshi Miyazaki 28/12/2000
    integer, dimension(3) :: matdSC, matdCS
    integer :: direction, k, stat, dpseudofns

    do k=1,3
       matdSC(k) = allocate_temp_matrix(SPrange,SP_trans,sf,nlpf)
       matdCS(k) = allocate_temp_matrix(PSrange,SP_trans,nlpf,sf)
    end do
    if(flag_basis_set==blips) dpseudofns = allocate_temp_fn_on_grid(nlpf)
    HF_NL_force = zero

    ! to save memory we do each direction in turn...
    do direction = 1, 3
       call matrix_scale(zero,matdSC(direction))
       call matrix_scale(zero,matdCS(direction))
       if(flag_basis_set==blips) then
          ! first of all construct the directional derivatives of the core
          ! functions on the grid
          select case(pseudo_type)
          case(OLDPS)
             call pseudopotential_derivatives(direction,dpseudofns)
          case(SIESTA)
             call nonloc_pp_derivative_tm(direction,dpseudofns)
          case(ABINIT)
             call nonloc_pp_derivative_tm(direction,dpseudofns)
          end select
          !if(direction.eq.3) then
          !   stop
          !else
          !   continue
          !endif
          ! now calculate overlap between these derivatives and support functions 
          ! New get_matrix_elements  TSUYOSHI MIYAZAKI 28/Dec/2000
          call get_matrix_elements_new(inode-1,rem_bucket(sf_nlpf_rem),matdSC(direction), supportfns,dpseudofns)
          call matrix_transpose(matdSC(direction),matdCS(direction))
          call matrix_scale(-one,matdCS(direction))
          ! and the overlap between the derivatives of the support and
          ! the core functions 
          call blip_to_grad_new(inode-1, direction, H_on_supportfns)
          call get_matrix_elements_new(inode-1,rem_bucket(sf_nlpf_rem),matdSC(direction), H_on_supportfns, pseudofns)
          call matrix_scale(-one,matdSC(direction))
          ! actually, because the derivatives we want are with respect to the
          ! position of the atom supporting each support function, we must
          ! scale the above integrals by -1
       else if(flag_basis_set==PAOs) then
          ! Get matrix elements between derivative of projectors and support functions
          call assemble_deriv_2(direction,SPrange,matdSC(direction),3)
          call matrix_scale(-one,matdSC(direction))
          
          ! Get matrix elements between projectors and derivative of support functions BY TRANSPOSE
          ! This is fine (I think) because the transpose ought to be exact
          call matrix_transpose(matdSC(direction),matdCS(direction))
          call matrix_scale(-one,matdCS(direction))
       else
          call cq_abort("get_HF_NL_force: basis set undefined ",flag_basis_set)
       end if
    enddo ! Now end the direction loop
    if(flag_basis_set==blips) call free_temp_fn_on_grid(dpseudofns)
    ! First of all, find U (=K.SC)
    call matrix_transpose(matSC,matCS)
    call matrix_product(matK,matCS,matU,mult(H_SP_SP))
    call matrix_scale(minus_four,matU)

    ! Find the transpose of U (=K.SC)
    call matrix_transpose(matU, matUT)
    ! For PAOs, we need to zero the on-site terms
    ! Evaluate the pulay term - due to the phis changing
    ! NB We want sum_k dSC_ik.UT_ki, so let's do sum_k dSC_ik.U_ik
    if(what_force==Pulay.OR.what_force==HF_and_Pulay) then
       do k=1,3
          call matrix_diagonal( matdSC(k), matU, HF_NL_force(k,:), SPrange,inode) 
       enddo
    end if
    ! Evaluate the Hellmann-Feynman term - due to the chis changing
    if(what_force==HF.OR.what_force==HF_and_Pulay) then
       do k=1,3
          call matrix_diagonal( matdCS(k), matUT, HF_NL_force(k,:), PSrange,inode) 
       enddo
    end if
    call gsum(HF_NL_force,3,n_atoms)
    do k=3,1,-1
       call free_temp_matrix(matdCS(k))
       call free_temp_matrix(matdSC(k))
    end do
    return
  end subroutine get_HF_non_local_force
!!***

! -----------------------------------------------------------
! Subroutine get_KE_force
! -----------------------------------------------------------

!!****f* force_module/get_KE_force *
!!
!!  NAME 
!!   get_KE_force
!!  USAGE
!! 
!!  PURPOSE
!!   Evaluates the force due to the change in the kinetic
!!   energy matrix when an atom moves. This is therefore
!!   the kinetic pulay type I force. As the onsite KE is evaluated
!!   on the blip grid, there is _no_ contribution; the contribution
!!   is due to the change in the intersite terms.
!!
!!   If we just have a single support function per atom...
!! (the extension to NSF!=1 is standard...)
!!   The gradient of the energy when atom i moves in direction \alpha
!!   is given by a sum over atoms j, directions \beta and the grid
!!
!! (d/dR_{i\alpha}) KE = 2 \sum_j \sum_{\beta} \sum_{grid} 
!!                         Grad_{\beta} psi_j  * 
!!                       (d/dR_{i\alpha}) Grad_{\beta} psi_i  *
!!                         K_{ij}   * grid_point_volume             [i!=j]
!!
!!   This can be written alternatively (more usefully) as
!!
!! (d/dR_{i\alpha}) KE = (d/dR_{i\alpha}) T_{ij} K_{ij}           [i!=j]
!!
!!   where
!!
!! (d/dR_{i\alpha}) T_{ij} = 2 \sum_{\beta} \sum_{grid}
!!                             grid_point_volume * Grad_{\beta} psi_j  * 
!!                           (d/dR_{i\alpha}) Grad_{\beta} psi_i
!!
!!   So within the loop over direction (for the force) we need a loop
!!   over the components of the grad (\beta). For each of these we
!!   evaluate Grad_{\beta} psi_j [blip_to_grad] and
!! (d/dR_{i\alpha}) Grad_{\beta} psi_i [blip_to_gradgrad], and thus
!! (d/dR_{i\alpha}) T_{ij} [get_matrix_elements].
!!   We then loop through the list of overlap range interactions, and
!!   accumulate the force due to that interaction onto the atom i.
!!
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   C.M.Goringe
!!  CREATION DATE
!!   03/03/97
!!  MODIFICATION HISTORY
!!   15/08/2000 TM
!!    New get_matrix_elements
!!   15/01/2001 TM 
!!    New blip_to_grad
!!   15/05/2001 dave
!!    ROBODoc headers, new get_matrix_elements
!!   17/05/2001 dave
!!    Shortened calls to blip_to_grad and blip_to_gradgrad
!!   21/05/2001 dave
!!    Shortened overall subroutine call
!!   11/06/2001 dave
!!    Added RCS Id and Log tags and GenComms
!!   12/06/2001 dave
!!    Included in force_module
!!   08:16, 2003/10/01 dave
!!    Added structure for preparing for PAO basis set
!!  SOURCE
!!
  subroutine get_KE_force( KE_force, n_atoms)

    use datatypes
    use numbers
    use primary_module, ONLY : bundle
    use matrix_module, ONLY: matrix, matrix_halo
    use matrix_data, ONLY:  mat, Hrange, halo
    use cover_module, ONLY: BCS_parts
    use mult_module, ONLY: allocate_temp_matrix, free_temp_matrix, return_matrix_value, matK, matrix_pos
    use GenBlas
    use set_bucket_module, ONLY: rem_bucket, sf_H_sf_rem
    use calc_matrix_elements_module, ONLY: get_matrix_elements_new
    use blip_grid_transform_module, ONLY: blip_to_grad_new, &
         blip_to_gradgrad_new
    use GenComms, ONLY: my_barrier, gsum, inode, ionode
    use global_module, ONLY: iprint_MD, flag_basis_set, blips, PAOs, sf, flag_onsite_blip_ana
    use build_PAO_matrices, ONLY: assemble_deriv_2
    use functions_on_grid, ONLY: H_on_supportfns, allocate_temp_fn_on_grid, free_temp_fn_on_grid

    implicit none

    ! Passed variables
    integer :: n_atoms

    real(double) :: KE_force(3, n_atoms)
    !     local variables
    integer :: i, j, grad_direction, force_direction, element, np, nn, atom, n1, n2
    integer :: mat_grad_T, ist, gcspart, iprim, tmp_fn


!    ! First, clear the diagonal blocks of data K; this is the easiest way 
!    ! to avoid doing the onsite terms
    KE_force = zero
    mat_grad_T = allocate_temp_matrix(Hrange,0)
    ! Now, for the offsite part, done on the integration grid.
    if(flag_basis_set==blips) then
       tmp_fn = allocate_temp_fn_on_grid(sf)
       call start_timer(tmr_std_matrices)
       do grad_direction = 1, 3 

          ! get the Grad_{\beta} psi_j term        
          call blip_to_grad_new(inode-1, grad_direction, H_on_supportfns)
          do force_direction = 1, 3

             ! get the (d/dR_{i\alpha}) Grad_{\beta} psi_i term        
             call blip_to_gradgrad_new(inode-1, grad_direction, force_direction, tmp_fn)

             ! now get the (d/dR_{i\alpha}) T_{ij} term from the above 
             !new matrix_elements
             call get_matrix_elements_new(inode-1,rem_bucket(sf_H_sf_rem),mat_grad_T, tmp_fn,H_on_supportfns)
             iprim = 0
             do np = 1,bundle%groups_on_node
                if(bundle%nm_nodgroup(np) > 0) then
                   do i=1,bundle%nm_nodgroup(np)
                      ! The numbering of the ig_prim index is the same as a sequential index 
                      ! running over atoms in the primary set (seen in pulay force for instance)
                      ! DRB and TM 10:38, 29/08/2003
                      iprim = iprim+1
                      atom = bundle%ig_prim(bundle%nm_nodbeg(np)+i-1)
                      do j = 1,mat(np,Hrange)%n_nab(i)
                         ist = mat(np,Hrange)%i_acc(i)+j-1
                         gcspart = BCS_parts%icover_ibeg(mat(np,Hrange)%i_part(ist))+mat(np,Hrange)%i_seq(ist)-1
                         element = matrix_pos(matK,iprim,halo(Hrange)%i_halo(gcspart),1,1)
                         if((.NOT.flag_onsite_blip_ana).OR.element/=mat(np,Hrange)%onsite(i)) then
                            do n1=1,mat(np,Hrange)%ndimj(ist)
                               do n2=1,mat(np,Hrange)%ndimi(i)
                                  KE_force(force_direction,atom) = KE_force(force_direction,atom) + &
                                       two*return_matrix_value(matK,np,i,iprim,j,n2,n1)* &
                                       return_matrix_value(mat_grad_T,np,i,iprim,j,n2,n1)
                                  !two*return_matrix_value_pos(matK,element+n2-1+(n1-1)*nsf)* &
                                  !     return_matrix_value_pos(mat_grad_T,element+n2-1+(n1-1)*nsf)
                               end do ! n2
                            end do !n1
                         end if
                      enddo !j=mat%n_nab
                   enddo !i=bundle%nm_nodgroup
                endif  ! (bundle%nm_nodgroup(np) > 0)
             enddo !np =bundle%groups_on_node
          end do ! force directions
       end do ! grad directions
       call stop_timer(tmr_std_matrices)
       call free_temp_fn_on_grid(tmp_fn)
    else if(flag_basis_set==PAOs) then
       do force_direction = 1, 3
          ! Build derivatives
          call assemble_deriv_2(force_direction,Hrange, mat_grad_T,2)
          call start_timer(tmr_std_matrices)
          iprim = 0
          do np = 1,bundle%groups_on_node
             if(bundle%nm_nodgroup(np) > 0) then
                do i=1,bundle%nm_nodgroup(np)
                   ! The numbering of the ig_prim index is the same as a sequential index 
                   ! running over atoms in the primary set (seen in pulay force for instance)
                   ! DRB and TM 10:38, 29/08/2003
                   atom = bundle%ig_prim(bundle%nm_nodbeg(np)+i-1)
                   iprim = iprim+1
                   do j = 1,mat(np,Hrange)%n_nab(i)
                      ist = mat(np,Hrange)%i_acc(i)+j-1
                      gcspart = BCS_parts%icover_ibeg(mat(np,Hrange)%i_part(ist))+mat(np,Hrange)%i_seq(ist)-1
                      element = matrix_pos(matK,iprim,halo(Hrange)%i_halo(gcspart),1,1)
                      if(element/=mat(np,Hrange)%onsite(i)) then
                         do n1=1,mat(np,Hrange)%ndimj(ist)
                            do n2=1,mat(np,Hrange)%ndimi(i)
                               KE_force(force_direction,atom) = KE_force(force_direction,atom) + &
                                    two*return_matrix_value(matK,np,i,iprim,j,n2,n1)* &
                                    return_matrix_value(mat_grad_T,np,i,iprim,j,n2,n1)
                               !two*return_matrix_value_pos(matK,element+n2-1+(n1-1)*nsf)* &
                               !return_matrix_value_pos(mat_grad_T,element+n2-1+(n1-1)*nsf)
                            end do ! n2
                         end do !n1
                      end if
                   enddo
                enddo
             endif  ! (bundle%nm_nodgroup(np) > 0)
          enddo
          call stop_timer(tmr_std_matrices)
       end do ! force directions
    end if
    call gsum(KE_force, 3, n_atoms)
    call free_temp_matrix(mat_grad_T)
    return
  end subroutine get_KE_force
!!***

! -----------------------------------------------------------
! Subroutine matrix_diagonal
! -----------------------------------------------------------

!!****f* force_module/matrix_diagonal *
!!
!!  NAME 
!!   matrix_diagonal
!!  USAGE
!! 
!!  PURPOSE
!!   Basically, this is designed for the non-local contribution to the 
!!   forces, and does sum_k one_ik.two^T_ki as sum_k one_ik two_ik
!!   We're being _very_ bad, and assuming that i_elements is sorted on 
!!   atom on node, so that the first n entries are for atom one on this
!!   node, etc.
!! 
!!   Now (a) complies with new matrix mults and (b) is used by lots of
!!   the force routines
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   7/7/98 (Happy 5 months Rob !)
!!  MODIFICATION HISTORY
!!   6/6/00 dave
!!    Changed to use new matrix mults
!!   21/06/2001 dave
!!    Added ROBODoc header and included in force_module
!!  SOURCE
!!
  subroutine matrix_diagonal( matA, matB, diagonal, range,inode)

    use datatypes
    use primary_module, ONLY : bundle
    use matrix_module, ONLY: matrix, matrix_halo
    use matrix_data, ONLY : mat, halo
    use cover_module, ONLY: BCS_parts
    use mult_module, ONLY: return_matrix_value_pos, matrix_pos
    use GenBlas

    implicit none

    ! Shared variables
    real(double) :: diagonal( :)

    integer :: range, inode,matA,matB

    ! Local variables
    integer :: iprim, np, i, j, atom,element, n1,n2, ist, gcspart

    iprim = 0
    call start_timer(tmr_std_matrices)
    do np = 1,bundle%groups_on_node
       if(bundle%nm_nodgroup(np) > 0) then
          do i=1,bundle%nm_nodgroup(np)
             iprim = iprim + 1
             atom = bundle%ig_prim(iprim)
             do j = 1,mat(np,range)%n_nab(i)
                ist = mat(np,range)%i_acc(i)+j-1
                gcspart = BCS_parts%icover_ibeg(mat(np,range)%i_part(ist))+mat(np,range)%i_seq(ist)-1
                do n2 = 1,mat(np,range)%ndimj(ist)
                   do n1 = 1,mat(np,range)%ndimi(i)
                      element = matrix_pos(matA,iprim,halo(range)%i_halo(gcspart),n1,n2)
                      diagonal(atom) = diagonal(atom) + &
                           return_matrix_value_pos(matA,element)*return_matrix_value_pos(matB,element)
                   end do
                end do
             enddo
          enddo
       endif  !  (bundle%nm_nodgroup(np) > 0)
    enddo
    call stop_timer(tmr_std_matrices)
    return
  end subroutine matrix_diagonal
!!***

! -----------------------------------------------------------
! Subroutine get_nonSC_correction_force
! -----------------------------------------------------------

!!****f* force_module/get_nonSC_correction_force *
!!
!!  NAME 
!!   get_nonSC_correction_force
!!  USAGE
!! 
!!  PURPOSE
!!   Gets the correction to the forces for when we're doing Harris-Foulkes (i.e. non self-consistent
!!   ab initio tight binding) calculations.  Operates in exactly the same manner as the Hellmann-Feynman 
!!   forces for the local part of the pseudopotential
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   16:12, 20/03/2003 drb 
!!  MODIFICATION HISTORY
!!   11:53, 30/09/2003 drb 
!!    Removed get_electronic_density (done above in force) and simplified subroutine call
!!   2004/10/05 drb
!!    Added hartree_module use
!!   14:08, 2006/07/17
!!    Added functional type selector and PBE force
!!  SOURCE
!!
  subroutine get_nonSC_correction_force( hf_force, potential, density_out, &
       inode, ionode, n_atoms, size)

    use datatypes
    use numbers
    use species_module, ONLY: species
    use GenComms, ONLY: gsum
    use global_module, ONLY: rcellx,rcelly,rcellz,id_glob,ni_in_cell,species_glob, dens, &
                             flag_functional_type, functional_lda_pz81, &
                             functional_lda_gth96, functional_lda_pw92, &
                             functional_gga_pbe96, area_moveatoms, IPRINT_TIME_THRES3
    use block_module, ONLY : nx_in_block,ny_in_block,nz_in_block, n_pts_in_block
    use group_module, ONLY : blocks, parts
    use primary_module, ONLY: domain
    use cover_module, ONLY: DCS_parts
    use set_blipgrid_module, ONLY : naba_atm
    use GenComms, ONLY: my_barrier, cq_abort
    use atomic_density, ONLY: atomic_density_table
    use spline_module, ONLY: dsplint
    use dimens, ONLY: grid_point_volume, n_my_grid_points
    use GenBlas, ONLY: axpy
    use density_module, ONLY: density, density_scale
    use hartree_module, ONLY: hartree
    use maxima_module, ONLY: maxngrid
    use memory_module, ONLY: reg_alloc_mem, reg_dealloc_mem, type_dbl
    use timer_module, ONLY: cq_timer,start_timer,stop_timer,print_timer, &
                            stop_print_timer,WITH_LEVEL,TIME_ACCUMULATE_NO,TIME_ACCUMULATE_YES

    implicit none

    ! Passed variables
    integer :: n_atoms, size
    integer :: inode, ionode

    real(double) :: hf_force( 3, n_atoms ), density_out( size )
    real(double), dimension(size) :: potential


    ! Local variables
    integer :: i, j, my_block, n, the_species, iatom
    integer :: ix,iy,iz,iblock,ipoint,igrid,stat
    integer :: ipart,jpart,ind_part,ia,ii,icover,ig_atom

    real(double) :: derivative, h_energy, rx, ry, rz, r2, r_from_i, x, y, z, step, pot_here
    real(double):: dcellx_block,dcelly_block,dcellz_block
    real(double):: dcellx_grid, dcelly_grid, dcellz_grid
    real(double):: xatom,yatom,zatom, fx_1, fy_1, fz_1
    real(double):: xblock,yblock,zblock
    real(double) :: dx,dy,dz, loc_cutoff, loc_cutoff2, electrons, v

    logical :: range_flag
    type(cq_timer) :: tmr_l_tmp1,tmr_l_tmp2

    ! Automatic
    real(double), allocatable, dimension(:) :: h_potential 

    HF_force = zero
    dcellx_block=rcellx/blocks%ngcellx; dcellx_grid=dcellx_block/nx_in_block
    dcelly_block=rcelly/blocks%ngcelly; dcelly_grid=dcelly_block/ny_in_block
    dcellz_block=rcellz/blocks%ngcellz; dcellz_grid=dcellz_block/nz_in_block

    ! We need a potential-like array containing the appropriate differences (between VHa for input and output 
    ! charge densities and between Vxc' for input and output densities)
    ! Something like this:
    call start_timer(tmr_std_allocation)
    allocate(h_potential(size), STAT=stat)
    if(stat/=0) call cq_abort('Error allocating h_potential in get_nonSC_force ',size,stat)
    call reg_alloc_mem(area_moveatoms, size,type_dbl)
    call stop_timer(tmr_std_allocation)
    ! First the PAD n(r), density
    call start_timer(tmr_l_tmp2) 
    potential = 0.0_double
    h_potential = 0.0_double
    call hartree( density, h_potential, maxngrid, h_energy )
    call axpy(size, one, h_potential, 1, potential, 1)
!    h_potential = 0.0_double
    call stop_timer(tmr_l_tmp2,TIME_ACCUMULATE_NO)      ! This restarts the count for this timer

    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    select case(flag_functional_type)
       case (functional_lda_pz81)
          call get_dxc_potential( density, h_potential, maxngrid )
       case (functional_lda_gth96)
          call get_GTH_dxc_potential( density, h_potential, maxngrid )
       case (functional_lda_pw92)
          call get_dxc_potential_LDA_PW92( density, h_potential, maxngrid )
       case (functional_gga_pbe96)
          call get_dxc_potential_GGA_PBE( density, density_out, potential, maxngrid )
       case default
          call get_dxc_potential( density, h_potential, maxngrid )
    end select

    if(flag_functional_type /= functional_gga_pbe96) then
      do i=1,n_my_grid_points
         potential(i) = potential(i)+density(i)*h_potential(i)
      end do
      ! Second the output n(r), density_out
      ! Now do the bit with n^output*mu'(n^PAD)
      do i=1,n_my_grid_points
         potential(i) = potential(i)-density_out(i)*h_potential(i)
      end do
    end if
    call stop_print_timer(tmr_l_tmp1,"NSC force - XC",IPRINT_TIME_THRES3)

    call start_timer(tmr_l_tmp2,WITH_LEVEL)   ! Restart of the timer; level assigned here
    h_potential = 0.0_double
    call hartree( density_out, h_potential, maxngrid, h_energy )
    call axpy(maxngrid, -one, h_potential, 1, potential, 1)
    call stop_print_timer(tmr_l_tmp2,"NSC force - Hartree",IPRINT_TIME_THRES3,TIME_ACCUMULATE_YES)

    call my_barrier()

    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    do iblock = 1, domain%groups_on_node ! primary set of blocks
       xblock=(domain%idisp_primx(iblock)+domain%nx_origin-1)*dcellx_block
       yblock=(domain%idisp_primy(iblock)+domain%ny_origin-1)*dcelly_block
       zblock=(domain%idisp_primz(iblock)+domain%nz_origin-1)*dcellz_block
       if(naba_atm(dens)%no_of_part(iblock) > 0) then ! if there are naba atoms
          iatom=0
          do ipart=1,naba_atm(dens)%no_of_part(iblock)
             jpart=naba_atm(dens)%list_part(ipart,iblock)
             if(jpart > DCS_parts%mx_gcover) call cq_abort('set_ps: JPART ERROR ',ipart,jpart)
             ind_part=DCS_parts%lab_cell(jpart)
             do ia=1,naba_atm(dens)%no_atom_on_part(ipart,iblock)
                iatom=iatom+1
                ii = naba_atm(dens)%list_atom(iatom,iblock)
                icover= DCS_parts%icover_ibeg(jpart)+ii-1
                ig_atom= id_glob(parts%icell_beg(ind_part)+ii-1)
                if(parts%icell_beg(ind_part) + ii-1 > ni_in_cell) &
                     call cq_abort('set_ps: globID ERROR ', ii,parts%icell_beg(ind_part))
                if(icover > DCS_parts%mx_mcover) &
                     call cq_abort('set_ps: icover ERROR ', icover,DCS_parts%mx_mcover)
                xatom=DCS_parts%xcover(icover)
                yatom=DCS_parts%ycover(icover)
                zatom=DCS_parts%zcover(icover)
                the_species = species_glob(ig_atom)
                !the_species=species(ig_atom)
                loc_cutoff = atomic_density_table(the_species)%cutoff
                loc_cutoff2 = loc_cutoff*loc_cutoff
                step = loc_cutoff/real(atomic_density_table(the_species)%length-1,double)
                ipoint=0
                do iz=1,nz_in_block
                   do iy=1,ny_in_block
                      do ix=1,nx_in_block
                         ipoint=ipoint+1
                         igrid=n_pts_in_block*(iblock-1)+ipoint
                         if(igrid > n_my_grid_points) call cq_abort('get_nonSC_force: igrid error ',igrid,n_my_grid_points)
                         pot_here = potential(igrid) * grid_point_volume
                         dx=dcellx_grid*(ix-1)
                         dy=dcelly_grid*(iy-1)
                         dz=dcellz_grid*(iz-1)
                         rx=xblock+dx-xatom
                         ry=yblock+dy-yatom
                         rz=zblock+dz-zatom
                         r2 = rx * rx + ry * ry + rz * rz
                         if(r2 < loc_cutoff2) then
                            r_from_i = sqrt( r2 )
                            if ( r_from_i > very_small ) then
                               x = rx / r_from_i
                               y = ry / r_from_i
                               z = rz / r_from_i
                            else
                               x = zero
                               y = zero
                               z = zero
                            end if
                            call dsplint(step,atomic_density_table(the_species)%table(:), & 
                                 atomic_density_table(the_species)%d2_table(:), &
                                 atomic_density_table(the_species)%length, & 
                                 r_from_i,v,derivative,range_flag)
                            if(range_flag) call cq_abort('get_nonSC_force: overrun problem')
                            fx_1 = -x * derivative*density_scale
                            fy_1 = -y * derivative*density_scale 
                            fz_1 = -z * derivative*density_scale 
                         else
                            fx_1 = zero
                            fy_1 = zero
                            fz_1 = zero
                         end if
                         HF_force(1,ig_atom) = HF_force(1,ig_atom) + fx_1 * pot_here 
                         HF_force(2,ig_atom) = HF_force(2,ig_atom) + fy_1 * pot_here
                         HF_force(3,ig_atom) = HF_force(3,ig_atom) + fz_1 * pot_here
                      enddo !ix
                   enddo  !iy
                enddo   !iz
             enddo ! naba_atoms
          enddo ! naba_part
       endif !(naba_atm(dens)%no_of_part(iblock) > 0) !naba atoms?
    enddo ! iblock : primary set of blocks
    call stop_print_timer(tmr_l_tmp1,"NSC force - Orbital part",IPRINT_TIME_THRES3)
    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    call gsum(HF_force,3,n_atoms)
    call stop_print_timer(tmr_l_tmp1,"NSC force - Compilation",IPRINT_TIME_THRES3)
    call start_timer(tmr_std_allocation)
    deallocate(h_potential,STAT=stat)
    if(stat/=0) call cq_abort('Error deallocating h_potential in get_nonSC_force ',stat)
    call reg_dealloc_mem(area_moveatoms, size,type_dbl)
    call stop_timer(tmr_std_allocation)
    return    
  end subroutine get_nonSC_correction_force
!!***

! -----------------------------------------------------------
! Subroutine get_dxc_potential
! -----------------------------------------------------------

!!****f* force_module/get_dxc_potential *
!!
!!  NAME 
!!   get_dxc_potential
!!  USAGE
!! 
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent 
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Perdew-Zunger parameterisation of the Ceperley-Alder 
!!   results for a homogeneous electron gas, as described in Phys. Rev. B 23, 5048 (1981), 
!!   with Ceperley-Alder in Phys. Rev. Lett. 45, 566 (1980)
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   09:36, 2003/03/20 dave
!!  MODIFICATION HISTORY
!!   2007/11/16 12:10 dave
!!    Bug fix: sign of ninth*(two*s+r)*rs term in dv_correlation was wrong
!!   2008/03/03 18:34 dave
!!    Removed dsqrt
!!  SOURCE
!!
  subroutine get_dxc_potential(density,dxc_potential,size )

    use datatypes
    use numbers
    use dimens, ONLY: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, ONLY: gsum

    implicit none

    ! Passed variables
    integer size

    real(double) :: density(size), dxc_potential(size)      

    !     Local variables
    integer n
    real(double) :: denominator, e_correlation, &
         e_exchange, ln_rs, vnumerator, &
         rcp_rs, rho, rs, rs_ln_rs, &
         sq_rs, dv_correlation, dv_exchange, dfirst, dsecond
    real(double), parameter :: alpha = -0.45817_double
    real(double), parameter :: beta_1 = 1.0529_double
    real(double), parameter :: beta_2 = 0.3334_double
    real(double), parameter :: gamma = - 0.1423_double 
    real(double), parameter :: p = 0.0311_double
    real(double), parameter :: q = - 0.048_double
    real(double), parameter :: r = 0.0020_double
    real(double), parameter :: s = - 0.0116_double
    real(double), parameter :: third = 1.0_double/3.0_double
    real(double), parameter :: ninth = 1.0_double/9.0_double
    real(double), parameter :: sixth = 1.0_double/6.0_double

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n) 
       if (rho>very_small) then ! Find radius of hole
          rcp_rs = ( four_thirds * pi * rho )**(third)
       else
          rcp_rs = zero
       end if
       ! First, the easy part: exchange
       e_exchange = alpha * rcp_rs
       if(rho>very_small) then
          dv_exchange = four*ninth * e_exchange/rho
       else
          dv_exchange = zero
       endif
       if (rcp_rs>zero) then
          rs = one/rcp_rs
       else
          rs = zero
       end if
       sq_rs = sqrt(rs)
       if (rs>=one) then
          denominator = one / (one + beta_1 * sq_rs + beta_2 * rs)
          vnumerator = one + seven_sixths * beta_1 * sq_rs +  &
               four_thirds * beta_2 * rs
          dfirst = (one + beta_1 * sq_rs + beta_2 * rs)*(-seven_thirtysixths*beta_1*sq_rs - four*ninth*beta_2*rs)
          dsecond = -two*vnumerator*(-sixth*beta_1*sq_rs-third*beta_2*rs)
          if(rho>very_small) then
             dv_correlation = gamma * (dfirst+dsecond) * denominator * denominator * denominator / rho
          else
             dv_correlation = zero
          end if
       else if ((rs<one).and.(rs>very_small)) then
          ln_rs = log(rs)
          rs_ln_rs = rs * ln_rs
          if(rho>very_small) then
             ! DRB 2007/11/16 Changed sign of ninth to PLUS to correct error
             dv_correlation = -(third*p+two*ninth*r*rs_ln_rs+ninth*(two*s+r)*rs)/rho
          else
             dv_correlation = zero
          end if
       else 
          dv_correlation = zero
       end if
       ! Both X and C
       dxc_potential(n) = (dv_exchange + dv_correlation)
       ! Just C 
       !dxc_potential(n) = dv_correlation
       ! Just X
       !dxc_potential(n) = dv_exchange
    end do ! do n_my_grid_points
    return
  end subroutine get_dxc_potential
!!***

! -----------------------------------------------------------
! Subroutine get_GTH_dxc_potential
! -----------------------------------------------------------

!!****f* force_module/get_GTH_dxc_potential *
!!
!!  NAME 
!!   get_GTH_dxc_potential
!!  USAGE
!! 
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent 
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Goedecker/Teter/Hutter parameterisation - 
!!   see PRB 54, 1703 (1996)
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   14:54, 25/03/2003 drb 
!!  MODIFICATION HISTORY
!!
!!  SOURCE
!!
  subroutine get_GTH_dxc_potential(density,dxc_potential,size )

    use datatypes
    use numbers
    use dimens, ONLY: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, ONLY: gsum

    implicit none

    ! Passed variables
    integer size

    real(double) :: density(size), dxc_potential(size)      

    !     Local variables
    integer n
    real(double) :: denominator, e_correlation, &
         e_exchange, ln_rs, vnumerator, &
         rcp_rs, rho, rs, rs_ln_rs,t1, t2, dt1, dt2, d2t1, d2t2, &
         sq_rs, dv_correlation, dv_exchange, dfirst, dsecond, drs_dRho, d2rs_dRho2
    real(double), parameter :: a0=0.4581652932831429_double
    real(double), parameter :: a1=2.217058676663745_double
    real(double), parameter :: a2=0.7405551735357053_double
    real(double), parameter :: a3=0.01968227878617998_double
    real(double), parameter :: b1=1.000000000000000_double
    real(double), parameter :: b2=4.504130959426697_double
    real(double), parameter :: b3=1.110667363742916_double
    real(double), parameter :: b4=0.02359291751427506_double    
    real(double), parameter :: third = 1.0_double/3.0_double

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n) 
       if (rho>very_small) then ! Find radius of hole
          rcp_rs = ( 4.0_double*third * pi * rho )**(third)
          rs = one/rcp_rs
       else
          rcp_rs = zero
          rs = zero
          rho = zero
       end if
       if(rs>zero) then
          drs_dRho = -rs / (3.0_double * rho)
          d2rs_dRho2 = 4.0_double * rs / (9.0_double * rho * rho)
          t1 = a0 + rs * (a1 + rs * (a2 + rs * a3))
          t2 = rs * (b1 + rs * (b2 + rs * (b3 + rs * b4)))
          dt1 = a1 + rs * (2.0_double * a2 + rs * 3.0_double * a3)
          dt2 = b1 + rs * (2.0_double * b2 + rs * (3.0_double * b3 + rs * 4.0_double * b4))
          d2t1 = 2.0_double * a2 + 6.0_double * a3 * rs
          d2t2 = 2.0_double * b2 + rs * (6.0_double * b3 + rs * 12.0_double * b4)
          dxc_potential(n) = 2.0_double*drs_dRho * (-dt1 / t2 + t1 * dt2 / (t2 * t2)) + &
               rho* &
               (drs_dRho*drs_dRho*(2.0_double*dt1*dt2/(t2*t2)-d2t1/t2-2.0_double*t1*dt2*dt2/(t2*t2*t2)+d2t2*t1/(t2*t2)) + &
               d2rs_dRho2*(-dt1 / t2 + t1 * dt2 / (t2 * t2)))
       else
          dxc_potential(n) = zero
       end if
    end do ! do n_my_grid_points
    return
  end subroutine get_GTH_dxc_potential
!!***


!!****f* H_matrix_module/get_dxc_potential_LDA_PW92 *
!!
!!  NAME
!!   get_dxc_potential_LDA_PW92
!!  USAGE
!!
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Perdew-Wang parameterisation of the Ceperley-Alder
!!   results for a homogeneous electron gas, as described in Phys. Rev. B 45, 13244 (1992),
!!   with Ceperley-Alder in Phys. Rev. Lett. 45, 566 (1980)
!!  INPUTS
!!
!!
!!  USES
!!
!!  AUTHOR
!!   A.S. Torralba
!!  CREATION DATE
!!   30/01/06
!!  MODIFICATION HISTORY
!!   2008/03/03 18:34 dave
!!    Removed dsqrt
!!  SOURCE
!!
  subroutine get_dxc_potential_LDA_PW92(density,dxc_potential,size, &
             eclda,declda_drho,d2eclda_drho2)

    use datatypes
    use numbers
    use dimens, ONLY: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, ONLY: gsum

    implicit none

    ! Passed variables
    integer size

    real(double) :: density(size), dxc_potential(size)
    real(double), optional :: eclda(size)
    real(double), optional :: declda_drho(size)
    real(double), optional :: d2eclda_drho2(size)

    !     Local variables
    integer n
    real(double) :: prefactor, postfactor, denominator, &
                    e_correlation, e_exchange, &
                    rcp_rs, rho, rs, sq_rs, &
                    v_correlation, v_exchange, &
                    delta_prefactor, delta_postfactor, &
                    dv_exchange, dv_correlation, &
                    denominator2, dnumrho_drho, &
                    dden_drho, rho4_3, &
                    dprefactor_drho, d2prefactor_drho2, &
                    dposfactor_drho, d2posfactor_drho2, &
                    dec_drho, d2ec_drho2


    !     From Table I, Phys. Rev. B 45, 13244 (1992), for reference
    real(double), parameter :: alpha  = 1.0421234_double
    real(double), parameter :: alpha1 = 0.21370_double
    real(double), parameter :: beta1  = 7.5957_double
    real(double), parameter :: beta2  = 3.5876_double
    real(double), parameter :: beta3  = 1.6382_double
    real(double), parameter :: beta4  = 0.49294_double
    real(double), parameter :: A      = 0.031091_double

    !     Precalculated constants
    real(double), parameter :: k00 = 1.611991954_double     ! (4*pi/3)**(1/3)
    real(double), parameter :: k01 = -0.458165347_double    ! -3/(2*pi*alpha)
    real(double), parameter :: k02 = -0.062182_double       ! -2*A
    real(double), parameter :: k03 = -0.0132882934_double   ! -2*A*alpha1
    real(double), parameter :: k04 = 0.4723158174_double    ! 2*A*beta1
    real(double), parameter :: k05 = 0.2230841432_double    ! 2*A*beta2
    real(double), parameter :: k06 = 0.1018665524_double    ! 2*A*beta3
    real(double), parameter :: k07 = 0.03065199508_double   ! 2*A*beta4
    real(double), parameter :: k08 = -0.008858862267_double ! 2*k03/3
    real(double), parameter :: k09 = 0.0787193029_double    ! k04/6
    real(double), parameter :: k10 = 0.074361381067_double  ! k05/3
    real(double), parameter :: k11 = 0.0509332762_double    ! k06/2
    real(double), parameter :: k12 = 0.0204346633867_double ! 2*k07/3
    real(double), parameter :: third = 0.333333333_double   ! 1/3
    real(double), parameter :: four_ninths = 4.0_double/9.0_double
    real(double), parameter :: minus_four_thirds = -4.0_double/3.0_double
    real(double), parameter :: k13 = 0.0027477997778_double ! (k08-k03)/k00

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n)

       !!!!   EXCHANGE
       if (rho > very_small) then ! Find radius of hole
          rcp_rs = k00 * ( rho**third )
          dv_exchange = four_ninths * k01 * rcp_rs / rho    ! 4*e_exchange/(9*rho)
       else
          rcp_rs = zero
          dv_exchange = zero
       end if

       e_exchange = k01*rcp_rs

       !!!!   CORRELATION
       if (rcp_rs > zero) then
          rs = one/rcp_rs
       else
          rs = zero
       end if
       sq_rs = sqrt(rs)

       prefactor = k02 + k03*rs
       denominator = sq_rs * ( k04 + sq_rs * ( k05 + sq_rs * ( k06 + k07 * sq_rs)))
       if (denominator > zero) then
          postfactor = log( 1 + 1/denominator )
       else
          postfactor = 0
       end if

       ! Return correlation energy if requested
       ! NOTE: This "energy" is not the actual integrand, but the integrand divided by rho
       if(present(eclda)) then
         eclda(n) = prefactor*postfactor
       end if


       ! NOTE: delta_prefactor is actually the derivative of rho*prefactor
       !       delta_postfactor is rho times the derivative of postfactor
       delta_prefactor  = k02 + k08*rs
       if (sq_rs > zero) then
          denominator2 = ( denominator * ( 1 + denominator ) )
          delta_postfactor = sq_rs * ( k09 + sq_rs*(k10 + sq_rs*( k11 + k12 * sq_rs ))) &
                           / denominator2

          dnumrho_drho = -sq_rs *( 7.0*k09/6.0 + sq_rs * ( 4.0*k10/3.0 + sq_rs * ( 3.0*k11/2.0 +sq_rs*5.0*k12/3.0)))
          dden_drho = -sq_rs*(k04/6.0 +sq_rs*(third*k05 + sq_rs*(half*k06 + sq_rs*2.0*k07/3.0)))
       else
          delta_postfactor = 0

          dnumrho_drho = zero
          dden_drho = zero
       end if

       if(rho > very_small) then
          rho4_3 = rho**minus_four_thirds
          dprefactor_drho   = k13*rho4_3
          d2prefactor_drho2 = minus_four_thirds*dprefactor_drho/rho

          dposfactor_drho   = delta_postfactor/rho
          d2posfactor_drho2 = (dnumrho_drho &
                            - delta_postfactor * ( 1 + 2*denominator) * dden_drho)/(denominator2 * rho *rho)
       else
          rho4_3 = zero
          dprefactor_drho   = zero
          d2prefactor_drho2 = zero

          dposfactor_drho   = zero
          d2posfactor_drho2 = zero
       end if

       dec_drho = postfactor*dprefactor_drho + prefactor*dposfactor_drho

       ! Return derivative of correlation energy (see note above) if requested
       if(present(declda_drho)) then
          declda_drho(n) = dec_drho
       end if


       d2ec_drho2 = 2*dposfactor_drho*dprefactor_drho &
                  + postfactor*d2prefactor_drho2 + prefactor*d2posfactor_drho2

       ! Return second derivative of correlation energy (see note above) if requested
       if(present(d2eclda_drho2)) then
          d2eclda_drho2(n) = d2ec_drho2
       end if

       dv_correlation = 2*dec_drho + rho*d2ec_drho2

       dxc_potential(n) = dv_exchange + dv_correlation
    end do ! do n_my_grid_points

    return
  end subroutine get_dxc_potential_LDA_PW92
!!***


! -----------------------------------------------------------
! Subroutine get_dxc_potential_GGA_PBE
! -----------------------------------------------------------

!!****f* H_matrix_module/get_dxc_potential_GGA_PBE *
!!
!!  NAME
!!   get_dxc_potential_GGA_PBE
!!  USAGE
!!
!!  PURPOSE
!!   Calculates the potential needed for the non-self-consistent 
!!   within GGA using the Perdew-Burke-Ernzerhof.
!!
!!   Note that this is the functional described in
!!   Phys. Rev. Lett. 77, 3865 (1996)
!!  INPUTS
!!
!!
!!  USES
!!
!!  AUTHOR
!!   A.S. Torralba
!!  CREATION DATE
!!   31/01/05
!!  MODIFICATION HISTORY
!!   15:54, 27/04/2007 drb 
!!    Changed recip_vector, grad_density and tmp2, tmp3 to (n,3) for speed
!!  SOURCE
!!
  subroutine get_dxc_potential_GGA_PBE(density,density_out, dxc_potential, size )

    use datatypes
    use numbers
    use global_module, ONLY: rcellx, rcelly, rcellz
    use dimens, ONLY: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points, n_grid_x, n_grid_y, n_grid_z
    use GenComms, ONLY: gsum, myid
    use energy, ONLY: delta_E_xc
    use fft_module, ONLY: fft3, recip_vector
    use H_matrix_module, ONLY: build_gradient, get_xc_potential_LDA_PW92

    implicit none

    ! Passed variables
    integer size
    real(double) :: density(size)
    real(double) :: density_out(size)
    real(double) :: dxc_potential(size)


    !     Local variables
    integer n, i

    real(double) :: grad_density(size), grad_density_xyz(size,3)
    real(double) :: rho, grad_rho, rho1_3, rho1_6
    real(double) :: e_exchange
    real(double) :: xc_energy_lda_total, dxc_potential_lda(size), &
                    eclda(size), declda_drho(size), d2eclda_drho2(size)
    real(double) :: de_dgrad(size)
    real(double) :: s, s2, factor0, factor1, denominator0, denominator0_2
    real(double) :: d2e_drho2, d2e_dgrad2(size), d2e_dgrad_drho(size)
    real(double) :: dden0_drho, df0f1_drho, ds_grad, dden0_dgrad, ds_dgrad, df1_dgrad
    real(double) :: diff_rho(size)
    complex(double_cplx) :: tmp1(size), tmp2(size,3)
    real(double) :: tmp3(size,3), tmp_factor

    real(double) :: a, a2, t, t2, t3, t4, num1, den1, den1_2, fl
    real(double) :: factor_exp, factor_exp2, factor_exp3
    real(double) :: dt_drho, da_drho, dnum1_drho, dden1_drho, dfl_drho, dec_drho
    real(double) :: dt_dgrad, dnum1_dgrad, dden1_dgrad, dfl_dgrad
    real(double) :: d2t_drho2, d2a_drho2, d2num1_drho2, d2den1_drho2, d2fl_drho2
    real(double) :: d2num1_dgrad2, d2den1_dgrad2, d2fl_dgrad2
    real(double) :: d2t_drho_dgrad, d2num1_drho_dgrad, d2den1_drho_dgrad
    real(double) :: d2fl_drho_dgrad
   
    !     From Phys. Rev. Lett. 77, 3865 (1996)
    real(double), parameter :: mu = 0.21951_double
    real(double), parameter :: kappa = 0.804_double
    real(double), parameter :: beta = 0.066725_double
    real(double), parameter :: gamma = 0.031091_double

    !     Precalculated constants
    real(double), parameter :: mu_kappa = 0.27302_double         ! mu/kappa
    real(double), parameter :: beta_gamma = 2.146119_double      ! beta/gamma
    real(double), parameter :: beta_X_gamma = 0.002074546_double ! beta*gamma
    real(double), parameter :: k01 = 0.16162045967_double        ! 1/(2*(3*pi*pi)**(1/3))
    real(double), parameter :: k02 = -0.16212105381_double       ! -3*mu*((4*pi/3)**3)/(2*pi*alpha)
                                                                 ! = mu*k00*k01(LDA_PW92)=mu*k04
    real(double), parameter :: k03 = 1.98468639_double           ! ((4/pi)*(3*pi*pi)**(1/3))**(1/2)
    real(double), parameter :: k04 = -0.738558852965_double      ! -3*((4*pi/3)**3)/(2*pi*alpha) = k00*k01 in LDA_PW92
    real(double), parameter :: k05 = 0.05240415_double           ! -2*k01*k02
    real(double), parameter :: third = 0.333333333_double        ! 1/3
    real(double), parameter :: eight = 8.0_double
    real(double), parameter :: eight_thirds = 8.0_double / 3.0_double

    ! Build the gradient of the density
    call build_gradient (density, grad_density, grad_density_xyz, size)

    ! Get the LDA part of the functional

    call get_dxc_potential_LDA_PW92(density, dxc_potential_lda, size, &
                                    eclda, declda_drho, d2eclda_drho2)

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n)
       grad_rho = grad_density(n)

       diff_rho(n) = density(n) - density_out(n)

       !!!!   EXCHANGE

       !!   Energy factors

       if (rho > very_small) then
          rho1_3 = rho ** third
          rho1_6 = sqrt (rho1_3)
          s = k01 * grad_rho / (rho ** four_thirds)
          s2 = s * s
          denominator0 = one / (one + mu_kappa * s2)
          denominator0_2 = denominator0 * denominator0
          factor0 = k02 * rho1_3
          factor1 = s2 * denominator0
          ! NOTE: This doesn't look like in Phys. Rev. Lett. 77:18, 3865 (1996)
          !       because the 1 in Fx, has been multiplied by Ex-LDA and is implicit
          !       in xc_energy_lda(n), in the total energy below
          e_exchange = factor0 * factor1
       else
          s  = 0.0_double              
          s2 = 0.0_double
          denominator0 = 0.0_double
          denominator0_2 = 0.0_double 
          factor0 = 0.0_double
          factor1 = 0.0_double
          e_exchange = zero
       end if

       !!   Second derivative of Ex wrt rho
       if (rho > very_small) then
          dden0_drho = mu_kappa * eight_thirds * denominator0_2 * s2 /rho
          df0f1_drho = third * e_exchange * (one - eight * denominator0) / rho
          d2e_drho2 = four_thirds * (df0f1_drho * (one - two * denominator0) &
                    - two * e_exchange * dden0_drho)
       else
          d2e_drho2 = 0.0_double
       end if

       !!   Second derivative of Ex wrt grad
       ds_dgrad = 0.0_double
       if(rho > very_small) ds_dgrad = k01 * rho**(-four_thirds)
       dden0_dgrad = -two * mu_kappa * denominator0_2 * s * ds_dgrad 

       d2e_dgrad2(n) = two * rho * factor0 * ds_dgrad * (ds_dgrad * denominator0_2 &
                     + two * s * denominator0 * dden0_dgrad)

       !!   Second derivative of Ex wrt grad and rho
       df1_dgrad = two * s * denominator0_2 * ds_dgrad

       d2e_dgrad_drho(n) = (four_thirds) * factor0 &
                         * (df1_dgrad * (one - two * denominator0) &
                         - two * factor1 * dden0_dgrad)

       !!   First derivative wrt gradient
       de_dgrad(n) = rho * factor0 * df1_dgrad



       !!!!   CORRELATION

       !!   Energy terms
       factor_exp = exp(-eclda(n)/gamma)
       a = factor_exp - one
       if(a > very_small) then
         a = beta_gamma / a
       else 
         a = beta_gamma * BIG
       end if
       a2 = a * a

       if(rho > very_small) then       
         t = grad_rho/(two*k03*(rho**seven_sixths))
       else
         t = 0.0_double
       end if
       t2 = t * t
       t3 = t2 * t
       t4 = t2 * t2
       num1 = one + a*t2;
       den1 = num1 + a2*t4;
       den1_2 = den1*den1;
       if(den1 > very_small) then
         fl = one + beta_gamma * t2 * num1 / den1;
       else
         fl = one
       end if


       !!   First derivative wrt rho
       
       if(rho > very_small) then 
         dt_drho = -seven_sixths*t/rho
       else
         dt_drho = 0.0_double
       end if
    !TM 2007_10_18  
    ! eclda(n) = 0 -> factor_exp = one -> zero**(-2) !!!
    !ORI   factor_exp2 = (factor_exp - one)**(-two)
     if(abs(factor_exp-one) > very_small) then
       factor_exp2 = one/(factor_exp - one)
       factor_exp2 = factor_exp2**2
     else
       factor_exp2 = 0.0_double
     endif

       da_drho = beta_gamma * factor_exp * factor_exp2 * declda_drho(n)/gamma
       dnum1_drho = da_drho * t2 + two*a*t*dt_drho
       dden1_drho = dnum1_drho + two*a*t4*da_drho + four*a2*t3*dt_drho
       if(den1 > very_small) then
         dfl_drho = beta_gamma*((two*t*num1*dt_drho + t2*dnum1_drho)/den1 - t2*num1*dden1_drho/den1_2)
       else
         dfl_drho = 0.0_double
       end if
       dec_drho = gamma * (log(fl) + rho * dfl_drho / fl)

       !!   Second derivative with respect to rho

       if(rho > very_small) then
         d2t_drho2 = seven_sixths*(t/(rho*rho) - dt_drho/rho)
       else
         d2t_drho2 = 0.0_double
       end if
       factor_exp3 = factor_exp * factor_exp2
      if(abs(factor_exp-one) > very_small) then
       d2a_drho2 = (beta_gamma/gamma)*( ( ( (two * factor_exp / (factor_exp - one)) - one )&
                 * factor_exp3 * declda_drho(n)**2) /gamma &
                 + factor_exp3 * d2eclda_drho2(n))
      else
       d2a_drho2 = zero
      endif

       d2num1_drho2 = d2a_drho2*t2 + four*t*da_drho*dt_drho &
                    + two*a*((dt_drho**2) + t*d2t_drho2)
       d2den1_drho2 = d2num1_drho2 + two*((da_drho*t2)**2) &
                    + two*a*d2a_drho2*t4 &
                    + 16.0_double*a*t3*da_drho*dt_drho &
                    + 12.0_double*((a*t*dt_drho)**2) &
                    + four*a2*t3*d2t_drho2
       if(den1 > very_small) then
         d2fl_drho2 = beta_gamma*(two*num1*(dt_drho**2) &
                    + t*(four*(dnum1_drho*dt_drho &
                    - num1*dden1_drho*dt_drho/den1) &
                    + two*num1*d2t_drho2) &
                    + t2*(d2num1_drho2 &
                    + two*(num1*((dden1_drho/den1)**2) &
                    - dnum1_drho*dden1_drho/den1) &
                    - num1*d2den1_drho2/den1))/den1
       else
         d2fl_drho2 = 0.0_double
       end if
       d2e_drho2 = d2e_drho2 + gamma*(two*dfl_drho/fl - rho*((dfl_drho/fl)**2) + rho*d2fl_drho2/fl);

       !!   First derivative with respect to grad

       if(rho > very_small) then 
         dt_dgrad = one/(two*k03*(rho**seven_sixths))
       else
         dt_dgrad = 0.0_double
       end if
       dnum1_dgrad = two*a*t*dt_dgrad
       dden1_dgrad = two*a*t*dt_dgrad + four*a2*t3*dt_dgrad
       if(den1 > very_small) then
          dfl_dgrad = two*beta_gamma*t*num1*dt_dgrad/den1 + beta_gamma*t2*dnum1_dgrad/den1  &
                 - beta_gamma*t2*num1*dden1_dgrad/den1_2
       else
          dfl_dgrad = 0.0_double
       end if
       de_dgrad(n) = de_dgrad(n) + gamma * rho * dfl_dgrad / fl
 
 
       !!   Second derivative with respect to grad
 
       d2num1_dgrad2 = two*a*(dt_dgrad**2)
       d2den1_dgrad2 = d2num1_dgrad2 + 12.0*((a*t*dt_dgrad)**2)
       if(den1 > very_small) then
        d2fl_dgrad2 = beta_gamma*(two*num1*(dt_dgrad**2)/den1 &
                    + four*t*dnum1_dgrad*dt_dgrad/den1 &
                    - two*t*num1*dden1_dgrad*dt_dgrad/den1_2 &
                    + t2*d2num1_dgrad2/den1 &
                    - t2*dden1_dgrad*dnum1_dgrad/den1_2 &
                    - two*t*num1*dden1_dgrad*dt_dgrad/den1_2 &
                    - t2*dnum1_dgrad*dden1_dgrad/den1_2 &
                    + two*t2*num1*(dden1_dgrad**2)/(den1_2*den1) &
                    - t2*num1*d2den1_dgrad2/den1_2)
       else
        d2fl_dgrad2 = zero
       endif
       d2e_dgrad2(n) = d2e_dgrad2(n) + gamma*rho*(d2fl_dgrad2/fl - (dfl_dgrad**2)/(fl*fl))
 
       !!   Second derivative with respect to rho and grad

       ! if((grad_rho > very_small ) .or. (rho > very_small)) then  ! Changed by TM 19Oct2007
       if((grad_rho > very_small ) .and. (rho > very_small)) then 
         d2t_drho_dgrad = -seven_sixths*t/(grad_rho*rho)
       else
         d2t_drho_dgrad = 0.0_double
       end if      
       d2num1_drho_dgrad = two*(t*da_drho*dt_dgrad + a*dt_drho*dt_dgrad + a*t*d2t_drho_dgrad)
       d2den1_drho_dgrad = d2num1_drho_dgrad + 8.0*a*t3*da_drho*dt_dgrad + 12.0*a2*t2*dt_drho*dt_dgrad &
                         + four*a2*t3*d2t_drho_dgrad
       if(den1 > very_small) then
          d2fl_drho_dgrad = beta_gamma*(two*(dt_drho*dt_dgrad*num1 &
                          + t*(dnum1_drho*dt_dgrad &
                          + num1*(d2t_drho_dgrad &
                          - (dden1_drho*dt_dgrad &
                          + dt_drho*dden1_dgrad)/den1) &
                          + dnum1_dgrad*dt_drho &
                         + t*num1*dden1_drho*dden1_dgrad/den1_2)) &
                         + t2*(d2num1_drho_dgrad &
                         - (dnum1_dgrad*dden1_drho &
                         + dnum1_drho*dden1_dgrad &
                         + num1*d2den1_drho_dgrad)/den1))/den1
       else
         d2fl_drho_dgrad = 0.0_double
       end if
        d2e_dgrad_drho(n) = d2e_dgrad_drho(n) + gamma*(dfl_dgrad + rho*(d2fl_drho_dgrad - dfl_drho*dfl_dgrad/fl))/fl
 
 
       !!   Add term L1 to the potential
       dxc_potential(n) = dxc_potential(n) &
                        + diff_rho(n) * (d2e_drho2 + dxc_potential_lda(n))

    end do ! do n_my_grid_points

    ! Fourier transform the difference of densities
     tmp1(:)=cmplx(zero,zero,double_cplx)  !TM
    call fft3(diff_rho, tmp1, size, -1)

    !do n=1, n_my_grid_points  ! debugged 25Oct2007 TM
    do n=1, size        
       ! Product by reciprocal vector stored for later use
       tmp2(n,1) = -minus_i*recip_vector(n,1)*tmp1(n)
       tmp2(n,2) = -minus_i*recip_vector(n,2)*tmp1(n)
       tmp2(n,3) = -minus_i*recip_vector(n,3)*tmp1(n)
    end do

    ! Fourier transform the vector back to the grid
    call fft3(tmp3(:,1), tmp2(:,1), size, 1)
    call fft3(tmp3(:,2), tmp2(:,2), size, 1)
    call fft3(tmp3(:,3), tmp2(:,3), size, 1)

    ! Add term L3 to potential
    do n=1, n_my_grid_points
       do i=1,3 
          if(grad_density(n) > very_small) then
            dxc_potential(n) = dxc_potential(n) + (tmp3(n,i) &
                                                * d2e_dgrad_drho(n) &
                                                * grad_density_xyz(n,i) )/grad_density(n)
          end if
       end do
    end do

    ! Term L4
    do n=1, n_my_grid_points
       if(grad_density(n) > very_small) then
         tmp_factor =(tmp3(n,1) * grad_density_xyz(n,1) &
                    + tmp3(n,2) * grad_density_xyz(n,2) &
                    + tmp3(n,3) * grad_density_xyz(n,3)) &
                    * (d2e_dgrad2(n) &
                    - de_dgrad(n)/grad_density(n) ) / (grad_density(n)*grad_density(n))
       else
         tmp_factor = zero
       end if
       ! Reuse tmp3
       do i=1,3
          if(grad_density(n) > very_small) then
            tmp3(n,i) = tmp_factor * grad_density_xyz(n,i) &
                      + de_dgrad(n) * tmp3(n,i)/grad_density(n)
          else
            tmp3(n,i) = zero
          end if
       end do
    end do

    ! Terms L2 and L5 (using L4)
    do n=1, n_my_grid_points
       do i=1,3
          if(grad_density(n) > very_small) then
            tmp3(n,i) = tmp3(n,i) &
                      + diff_rho(n) * d2e_dgrad_drho(n)* grad_density_xyz(n,i) &
                      / grad_density(n)
          else
            tmp3(n,i) = zero
          end if
       end do
    end do

    tmp2(:,:) = cmplx(zero,zero,double_cplx) ! 25Oct2007 TM
    call fft3(tmp3(:,1), tmp2(:,1), size, -1)
    call fft3(tmp3(:,2), tmp2(:,2), size, -1)
    call fft3(tmp3(:,3), tmp2(:,3), size, -1)

    !do n=1, n_my_grid_points  ! debugged 25Oct2007 TM
    do n=1, size
       ! Product by reciprocal vector stored for later use
       tmp1(n) = -minus_i &
               *(recip_vector(n,1)*tmp2(n,1) &
               + recip_vector(n,2)*tmp2(n,2) &
               + recip_vector(n,3)*tmp2(n,3))
    end do

    ! Use first component of tmp3 to store final vector
    call fft3(tmp3(:,1), tmp1, size, 1)    

    do n=1, n_my_grid_points
       dxc_potential(n) = dxc_potential(n) - tmp3(n,1)
    end do

    return
  end subroutine get_dxc_potential_GGA_PBE
!!***

end module force_module
