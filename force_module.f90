! -*- mode: F90; mode: font-lock; column-number-mode: true; vc-back-end: CVS -*-
! ------------------------------------------------------------------------------
! $Id$
! ------------------------------------------------------------------------------
! Module force_module
! ------------------------------------------------------------------------------
! Code area 7: moving atoms
! ------------------------------------------------------------------------------

!!****h* Conquest/force_module *
!!  NAME
!!   force_module
!!  PURPOSE
!!   Gathers together the force routines and variables
!!  USES
!!   atoms, blip_grid_transform_module, blip,
!!   calc_matrix_elements_module, common, datatypes, DiagModule,
!!   dimens, ewald_module, generic_blas, generic_comms, global_module,
!!   grid_index, H_matrix_module, logicals, matrix_data,
!!   maxima_module, multiply_module, mult_module, numbers,
!!   primary_module, pseudopotential_data, set_bucket_module,
!!   S_matrix_module, species_module
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   12/06/2001 dave
!!  MODIFICATION HISTORY
!!   21/06/2001 dave
!!    Included matrix_diagonal
!!    Removed use matrix_diag in get_HF_non_local_force
!!    Removed matrix scaling from same
!!   13/05/2002 dave
!!    Added RCS id variable and TODO to get_HF_force - this needs fixing !
!!   29/05/2002 dave
!!    Added flag to check for ordern before getting K, also RCS static
!!    object and tweaked headers
!!   31/07/2002 dave
!!    Changed pulay_force to use data_M12 from matrix_data and not to
!!    pass it to get_support_gradient
!!   15:42, 08/04/2003 drb 
!!    Bug fixes (factor of 1/3 in XC, sign in nonSC), added nonSC
!!    forces and differential of GTH XC LDA parameterisation
!!   14:20, 02/09/2003 drb 
!!    Added parameters to allow the non-local routine to find HF, phi
!!    Pulay or both.
!!   11:51, 30/09/2003 drb
!!    Mainly changes to correct non-SC forces
!!   10:09, 13/02/2006 drb 
!!    Removed all explicit references to data_ variables and rewrote
!!    in terms of new
!!    matrix routines
!!   2008/02/06 08:14 dave
!!    Changed for output to file not stdout
!!   2011/03/31 11:52 M.Arita
!!    Added sbrt get_pcc_force and modified sbrt get_nonSC_correction
!!    for P.C.C.
!!   2011/10/03 08:17 dave
!!    Adding cDFT forces
!!   2012/04/03 09:38 dave
!!    Changes for analytic blips
!!  SOURCE
!!
module force_module

  use datatypes
  use global_module,          only: io_lun
  use timer_stdclocks_module, only: start_timer, stop_timer, &
                                    tmr_std_allocation,      &
                                    tmr_std_matrices

  implicit none

  save

  real(double), dimension(:,:), allocatable :: tot_force

  ! Useful parameters for selecting force calculations in NL part
  integer, parameter :: HF = 1
  integer, parameter :: Pulay = 2
  integer, parameter :: HF_and_Pulay = 3

  ! RCS tag for object file identification
  character(len=80), private :: &
       RCSid = "$Id$"

!!***

contains

  ! ------------------------------------------------------------------------------
  ! Subroutine force
  ! ------------------------------------------------------------------------------
  
  !!****f* force_module/force *
  !!
  !!  NAME 
  !!   force
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Collects all force calculations in one place
  !! 
  !! ********************
  !! ** IMPORTANT NOTE **
  !! ********************
  !!
  !!   I know it shouldn't be like this, but it is: the order of the
  !!   calls is VITAL ! pulay_force assumes that workspace_support
  !!   contains h_on_support (as generated by get_H_matrix) so should be
  !!   first (or should regenerate h_on_support).  get_KE_force
  !!   overwrites the on-site blocks of data_K with zeroes, and so
  !!   should LAST !
  !!
  !!  INPUTS
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   D.R.Bowler
  !!  CREATION DATE
  !!   Sometime in 1998, I think
  !!  MODIFICATION HISTORY
  !!   15/05/2001 dave
  !!    F90, indenting and ROBODoc
  !!   21/05/2001 dave
  !!    Reduced calls to get_HF_force and get_KE_force
  !!    Reduced call to pulay_force
  !!   22/05/2001 dave
  !!    Bug fixes
  !!    Shortened overall subroutine call and comments 
  !!    before subroutine calls
  !!   08/06/2001 dave
  !!    Added GenComms for my_barrier and RCS Id and Log tags
  !!   12/06/2001 dave
  !!    Included in force_module
  !!   13/05/2002 dave
  !!    Tidied format statements
  !!   11:52, 30/09/2003 drb 
  !!    Added density_out variable to store output density for non-SC
  !!    calculations and changed call to get_nonSC_correction_force.
  !!    Also added call to get_electronic_density.  Also placed
  !!    pulay_force call
  !!    FIRST (as it needs h_on_support in workspace_support).
  !!   12:00, 31/03/2011 M.Arita
  !!    Added the contributions from P.C.C.
  !!   2011/09/19 L.Tong
  !!    Added Spin Polarisation
  !!    - removed reference to potential of potential_module, this is
  !!      now referenced in get_nonSC_correction_force subroutine
  !!   2011/10/03 08:17 dave
  !!    Calls for cDFT
  !!   2011/11/28 L.Tong
  !!    Removed redundant dependency on number_of_bands
  !!   2012/03/26 L.Tong
  !!   - Changed spin implementation
  !!   - removed redundant input parameter real(double) mu
  !!   2012/04/03 09:39 dave
  !!    Added KE force to pulay force call (for analytic blips)
  !!  SOURCE
  !!
  subroutine force(fixed_potential, vary_mu, n_cg_L_iterations, &
                   tolerance, con_tolerance, total_energy,      &
                   expected_reduction, write_forces)

    use datatypes
    use numbers
    use units
    use timer_module
    use ewald_module,           only: ewald_force
    use pseudopotential_data,   only: non_local
    use GenComms,               only: my_barrier, inode, ionode,       &
                                      cq_abort
    ! TM new pseudo
    use pseudopotential_common, only: pseudo_type, OLDPS, SIESTA,      &
                                      STATE, ABINIT
    use pseudo_tm_module,       only: loc_pp_derivative_tm
    use global_module,          only: flag_self_consistent,            &
                                      flag_move_atom, id_glob,         &
                                      WhichPulay, BothPulay, PhiPulay, &
                                      SPulay, flag_basis_set, PAOs,    &
                                      blips, ni_in_cell, iprint_MD,    &
                                      IPRINT_TIME_THRES2,              &
                                      area_moveatoms, flag_pcc_global, &
                                      flag_perform_cdft, flag_dft_d2,  &
                                      nspin, spin_factor, flag_analytic_blip_int
    use density_module,         only: get_electronic_density, density, &
                                      build_Becke_weight_forces
    use functions_on_grid,      only: supportfns, H_on_supportfns
    use dimens,                 only: n_my_grid_points
    use maxima_module,          only: maxngrid
    use memory_module,          only: reg_alloc_mem, reg_dealloc_mem,  &
                                      type_dbl
    use DFT_D2,                 only: disp_force

    implicit none

    ! Passed variables
    logical      :: vary_mu, fixed_potential, write_forces
    integer      :: n_cg_L_iterations
    real(double) :: tolerance, con_tolerance, total_energy, &
                    expected_reduction

    ! Local variables
    integer        :: i, j, ii, stat, max_atom, max_compt, spin
    real(double)   :: max_force
    type(cq_timer) :: tmr_l_tmp1
    real(double), dimension(nspin)    :: electrons
    real(double), dimension(maxngrid) :: density_total
    real(double), dimension(:,:), allocatable :: p_force,         &
                                                 cdft_force,      &
                                                 HF_force,        &
                                                 HF_NL_force,     &
                                                 KE_force,        &
                                                 nonSC_force,     &
                                                 pcc_force
    real(double), dimension(:),   allocatable :: density_out_tot
    real(double), dimension(:,:), allocatable :: density_out

    call start_timer(tmr_std_allocation)
    if (flag_pcc_global) then
       allocate(p_force(3,ni_in_cell), KE_force(3,ni_in_cell),      &
                HF_force(3,ni_in_cell), HF_NL_force(3,ni_in_cell),  &
                nonSC_force(3,ni_in_cell), pcc_force(3,ni_in_cell), &
                STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error allocating forces: ", ni_in_cell)
       call reg_alloc_mem(area_moveatoms, 6 * 3 * ni_in_cell, type_dbl)
    else
       allocate(p_force(3,ni_in_cell), KE_force(3,ni_in_cell),     &
                HF_force(3,ni_in_cell), HF_NL_force(3,ni_in_cell), &
                nonSC_force(3,ni_in_cell), STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error allocating forces: ", ni_in_cell)
       call reg_alloc_mem(area_moveatoms, 5 * 3 * ni_in_cell, type_dbl)
    end if
    if (flag_perform_cdft) then
       allocate(cdft_force(3,ni_in_cell), STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error allocating cdft_force: ", ni_in_cell)
       call reg_alloc_mem(area_moveatoms, 3 * ni_in_cell, type_dbl)
       cdft_force = zero
    end if
    call stop_timer (tmr_std_allocation)
    ! get total density
    density_total = spin_factor * sum(density, 2)

    ! The 'pulay force' is the force due to the change in energy caused
    ! by the change in the basis functions as the atoms move. 
    p_force = zero
    KE_force = zero
    HF_force = zero
    HF_NL_force = zero
    nonSC_force = zero
    if (flag_pcc_global) pcc_force = zero ! for P.C.C.
    tot_force = zero
    WhichPulay = BothPulay    
    ! This ASSUMES that H_on_supportfns contains the values of H
    ! acting on support functions
    call start_timer(tmr_l_tmp1, WITH_LEVEL)
    call pulay_force(p_force, KE_force, fixed_potential, vary_mu, &
                     n_cg_L_iterations, tolerance, con_tolerance, &
                     total_energy, expected_reduction, ni_in_cell)
    call stop_print_timer(tmr_l_tmp1, "Pulay force", IPRINT_TIME_THRES2)
    call start_timer(tmr_l_tmp1, WITH_LEVEL)
    if (flag_perform_cdft) then
       call build_Becke_weight_forces(cdft_force)
    end if
    call stop_print_timer(tmr_l_tmp1, "cDFT force", IPRINT_TIME_THRES2)
    
    ! Different forces depending on whether we're doing Harris-Foulkes
    ! or self-consistent
    if (.not. flag_self_consistent) then

       call start_timer(tmr_std_allocation)
       allocate(density_out(maxngrid,nspin), &
                density_out_tot(maxngrid), STAT=stat)
       if (stat /= 0) &
            call cq_abort ("Error allocating output density: ", stat)
       call reg_alloc_mem(area_moveatoms, maxngrid * (nspin + 1), type_dbl)
       density_out = zero
       density_out_tot = zero
       call stop_timer(tmr_std_allocation)

       call start_timer(tmr_l_tmp1,WITH_LEVEL)
       call get_electronic_density(density_out, electrons,         &
                                   supportfns, H_on_supportfns(1), &
                                   inode, ionode, maxngrid)
       ! get the total density_out
       density_out_tot = spin_factor * sum(density_out, 2)
       call stop_print_timer(tmr_l_tmp1, "get_electronic_density", &
                             IPRINT_TIME_THRES2)
       call start_timer(tmr_l_tmp1, WITH_LEVEL)
       ! for P.C.C.
       if (flag_pcc_global) then
          call get_pcc_force(pcc_force, inode, ionode, ni_in_cell, &
                             maxngrid)
       end if
       call get_nonSC_correction_force(nonSC_force, density_out,  &
                                       inode, ionode, ni_in_cell, &
                                       maxngrid)
       call stop_print_timer(tmr_l_tmp1, "NSC force", IPRINT_TIME_THRES2)
       
       ! Local HF force
       call start_timer(tmr_l_tmp1, WITH_LEVEL)
       select case (pseudo_type)
       case (OLDPS)
          call get_HF_force(hf_force, density_out_tot, ni_in_cell, maxngrid)
       case (SIESTA)
          call loc_pp_derivative_tm(hf_force, density_out_tot, maxngrid)
       case (ABINIT)
          call loc_pp_derivative_tm(hf_force, density_out_tot, maxngrid)
       end select
       call stop_print_timer(tmr_l_tmp1, "local pseudopotential force", &
                             IPRINT_TIME_THRES2)
       call start_timer(tmr_std_allocation)
       ! deallocate the temporary arrays
       deallocate(density_out_tot, density_out, STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error deallocating output density: ", &
                          maxngrid)
       call reg_dealloc_mem(area_moveatoms, maxngrid * (nspin + 1), type_dbl)
       call stop_timer(tmr_std_allocation)
    else ! for SCF
       ! Local HF force
       call start_timer(tmr_l_tmp1, WITH_LEVEL)
       ! for P.C.C.
       if (flag_pcc_global) then
          call get_pcc_force(pcc_force, inode, ionode, ni_in_cell, maxngrid)
       end if
       select case (pseudo_type)
       case (OLDPS)
          call get_HF_force(hf_force, density_total, ni_in_cell, maxngrid)
       case (SIESTA)
          call loc_pp_derivative_tm(hf_force, density_total, maxngrid)
       case (ABINIT)
          call loc_pp_derivative_tm(hf_force, density_total, maxngrid)
       end select
       call stop_print_timer(tmr_l_tmp1, "local pseudopotential force", &
                             IPRINT_TIME_THRES2)
    end if ! (.not. flag_self_consistent)

    ! This routine deals with the movement of the nonlocal pseudopotential.
    if (non_local) then
       call start_timer(tmr_l_tmp1, WITH_LEVEL)
       call get_HF_non_local_force(HF_NL_force, HF_and_Pulay, ni_in_cell)
       call stop_print_timer(tmr_l_tmp1, "nonlocal pseudopotential force", &
                             IPRINT_TIME_THRES2)
    else
       HF_NL_force = zero
    end if
    ! Get the kinetic energy force component
    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    if(.NOT.flag_analytic_blip_int) call get_KE_force(KE_force, ni_in_cell)
    call stop_print_timer(tmr_l_tmp1, "kinetic energy force", &
                          IPRINT_TIME_THRES2)

    max_force = zero
    if (inode == ionode .and. write_forces) then
       write (io_lun, fmt='(/,20x,"Forces on atoms (",a2,"/",a2,")"/)') &
             en_units(energy_units), d_units(dist_units)
       write (io_lun, fmt='(18x,"    Atom   X              Y              Z")')
    end if

    ! with P.C.C.
    if (flag_pcc_global) then
      do i = 1, ni_in_cell
         do j = 1, 3
            ! note that ewald_force is already calculated by ewald()
            ! when ewald energy is being calculated
            if (flag_self_consistent) then
               tot_force(j,i) = HF_force(j,i) + HF_NL_force(j,i) + &
                                p_force(j,i) + KE_force(j,i) +     &
                                ewald_force(j,i) + pcc_force(j, i)
            else
               tot_force(j,i) = HF_force(j,i) + HF_NL_force(j,i) +    &
                                p_force(j,i) + KE_force(j,i) +        &
                                ewald_force(j,i) + nonSC_force(j,i) + &
                                pcc_force(j, i)
            end if
            if (flag_perform_cdft) &
                 tot_force(j,i) = tot_force(j,i) + cdft_force(j,i)
            if (flag_dft_d2) &
                 tot_force(j,i) = tot_force(j,i) + disp_force(j,i)
            if (.not. flag_move_atom(j,i)) then 
               tot_force(j,i) = zero
            end if
            if (abs (tot_force(j,i)) > max_force) then
               max_force = abs (tot_force(j,i))
               max_atom = i
               max_compt = j
            end if
         end do
         if (inode == ionode) then
            if(iprint_MD > 2) then
               write(io_lun, 101) i
               write(io_lun, 102) (for_conv * HF_force(j,i), j = 1, 3)
               write(io_lun, 112) (for_conv * HF_NL_force(j,i), j = 1, 3)
               write(io_lun, 103) (for_conv * p_force(j,i), j = 1, 3)
               write(io_lun, 104) (for_conv * KE_force(j,i), j = 1, 3)
               write(io_lun, 106) (for_conv * ewald_force(j,i), j = 1, 3)
               write(io_lun, 108) (for_conv * pcc_force(j,i), j = 1, 3)
               if (flag_dft_d2) &
                    write (io_lun, 109) (for_conv * disp_force(j,i), j = 1, 3)
               if (flag_perform_cdft) &
                    write (io_lun, fmt='("Force cDFT : ",3f15.10)') &
                    (for_conv*cdft_force(j,i),j=1,3)
               if (flag_self_consistent) then
                  write (io_lun, 105) (for_conv * tot_force(j,i), j = 1, 3)
               else
                  write (io_lun, 107) (for_conv * nonSC_force(j,i), j = 1, 3)
                  write (io_lun, 105) (for_conv * tot_force(j,i), j = 1, 3)
               end if
            else if (write_forces) then
               if (flag_self_consistent) then
                  write (io_lun,fmt='(20x,i6,3f15.10)') &
                       i, (for_conv * tot_force(j,i), j = 1, 3)
               else
                  write (io_lun, fmt='(20x,i6,3f15.10)') &
                       i, (for_conv * tot_force(j,i), j = 1, 3)
               end if
            end if ! (iprint_MD > 2)
         end if ! (inode == ionode)
      end do ! i
   else  ! without P.C.C.
      do i = 1, ni_in_cell
         do j = 1, 3
            if (flag_self_consistent) then
               tot_force(j,i) = HF_force(j,i) + HF_NL_force(j,i) + &
                                p_force(j,i) + KE_force(j,i) +     &
                                ewald_force(j,i)
            else
               tot_force(j,i) = HF_force(j,i) + HF_NL_force(j,i) + &
                                p_force(j,i) + KE_force(j,i) +     &
                                ewald_force(j,i) + nonSC_force(j,i)
            end if
            if (flag_perform_cdft) &
                 tot_force(j,i) = tot_force(j,i) + cdft_force(j,i)
            if (flag_dft_d2) &
                 tot_force(j,i) = tot_force(j,i) + disp_force(j,i)
            if (.not. flag_move_atom(j,i)) then 
               tot_force(j,i) = zero
            end if
            if (abs(tot_force(j,i)) > max_force) then
               max_force = abs(tot_force(j,i))
               max_atom = i
               max_compt = j
            end if
         end do ! j
         if (inode == ionode) then
            if (iprint_MD > 2) then
               write (io_lun, 101) i
               write (io_lun, 102) (for_conv * HF_force(j,i), j = 1, 3)
               write (io_lun, 112) (for_conv * HF_NL_force(j,i), j = 1, 3)
               write (io_lun, 103) (for_conv * p_force(j,i), j = 1, 3)
               write (io_lun, 104) (for_conv * KE_force(j,i), j = 1, 3)
               write (io_lun, 106) (for_conv * ewald_force(j,i), j = 1, 3)
               if (flag_dft_d2) write (io_lun, 109) &
                    (for_conv * disp_force(j,i), j = 1, 3)
               if (flag_perform_cdft) &
                    write (io_lun,fmt='("Force cDFT : ",3f15.10)') &
                          (for_conv * cdft_force(j,i), j = 1, 3)
               if (flag_self_consistent) then
                  write (io_lun, 105) (for_conv*tot_force(j,i), j = 1, 3)
               else
                  write (io_lun, 107) (for_conv * nonSC_force(j,i), j = 1, 3)
                  write (io_lun, 105) (for_conv * tot_force(j,i), j = 1, 3)
               end if
            else if (write_forces) then
               if (flag_self_consistent) then
                  write (io_lun, fmt='(20x,i6,3f15.10)') &
                        i, (for_conv*tot_force(j,i), j = 1, 3)
               else
                  write (io_lun,fmt='(20x,i6,3f15.10)') &
                        i, (for_conv*tot_force(j,i), j = 1, 3)
               end if
            end if
         end if
      end do ! i
    end if ! flag_pcc_global
    
    call my_barrier()
    if (inode == ionode) &
         write (io_lun,                                      &
                fmt='(4x,"Maximum force : ",f15.8,"(",a2,"/",&
                      &a2,") on atom, component ",2i9)')     &
               for_conv * max_force, en_units(energy_units), &
               d_units(dist_units), max_atom, max_compt
    if (inode == ionode .and. iprint_MD > 1 .and. write_forces) &
         write (io_lun, fmt='(4x,"Finished force")')

    call start_timer(tmr_std_allocation)
    if (flag_pcc_global) then
       deallocate(p_force, KE_force, HF_force, HF_NL_force, &
                  nonSC_force, pcc_force, STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error deallocating forces: ", ni_in_cell)
       call reg_dealloc_mem(area_moveatoms, 6 * 3 * ni_in_cell, type_dbl)
    else
       deallocate(p_force, KE_force, HF_force, HF_NL_force, &
                  nonSC_force, STAT=stat)
       if (stat /= 0) &
            call cq_abort("Error deallocating forces: ", ni_in_cell)
       call reg_dealloc_mem(area_moveatoms, 5 * 3 * ni_in_cell, type_dbl)
    end if
    call stop_timer(tmr_std_allocation)

    return

101 format('Force on atom ',i9)
102 format('Force H-F  : ',3f15.10)
112 format('Force H-Fnl: ',3f15.10)
103 format('Force pulay: ',3f15.10)
104 format('Force KE   : ',3f15.10)
106 format('Force Ewald: ',3f15.10)
107 format('Force nonSC: ',3f15.10)
108 format('Force PCC  : ',3f15.10)
105 format('Force Total: ',3f15.10)
109 format('Force disp : ',3f15.10)
    
  end subroutine force
  !!***


  ! -----------------------------------------------------------
  ! Subroutine pulay_force
  ! -----------------------------------------------------------
  
  !!****f* force_module/pulay_force *
  !!
  !!  NAME 
  !!   pulay_force
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Evaluates the Pulay contribution to the forces on
  !!   the atoms. This is the change in energy due to
  !!   the movement of the blip functions causing a change in support
  !!   function. The change in energy wrt blip functions is zero (variational)
  !!   but the change in energy wrt the variation of a given support function
  !!   at a given point is not in general zero. If the atom moves, all the
  !!   blip functions associated with it move, and there is a corresponding
  !!   change in the values of the support functions. The gradient of the
  !!   support functions wrt movement of the atoms with which they are
  !!   associated is held in gradsupport. This need to be integrated with
  !!   the gradient of energy wrt change in support functions, which is
  !!   given by the subroutine get_support_gradient.
  !!  INPUTS
  !! 
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   C.M.Goringe
  !!  CREATION DATE
  !!   13/09/95
  !!  MODIFICATION HISTORY
  !!   24/4/96 Chris Goringe
  !!    We have changed the data format, and these changes are required to 
  !!    deal with it. blip_to_gradsupport is now replaced by the general
  !!    blip_transform routine
  !!
  !!   24/2/97 Chris Goringe
  !!    Quite a lot of other changes have occured in the code, in particular
  !!    we no longer ever get the grad of the support functions; we just
  !!    get it one component at a time.
  !!  
  !!    workspace_support  is used to hold the gradient of energy wrt
  !!                       support functions
  !!    workspace2_support is used to hold gradient of support functions
  !!                       with respect to atomi position
  !!   17/5/97 DRB to implement HeadGordon
  !!   02/02/2001 TM
  !!    blip_to_support_new, get_matrix_elements_new, blip_to_grad_new
  !!   16/05/2001 dave
  !!    F90 format, ROBODoc, new blip_to_grad call
  !!   18/05/2001 dave
  !!    Fixed the get_H_matrix call
  !!   22/05/2001 dave
  !!    Stripped subroutine call
  !!   23/05/2001 dave
  !!    Various small fixes
  !!   12/06/2001 dave
  !!    Included in force_module
  !!   29/05/2002 dave
  !!    Added flag from DiagModule so that K isn't made if we're diagonalising
  !!   31/07/2002 dave
  !!    Changed to use data_M12 from matrix_data and changed call to
  !!    get_support_gradient to remove data_M12
  !!   14:49, 2003/06/09 dave
  !!    Added use statement for blip_gradient (get_support_gradient moved)
  !!   08:06, 2003/10/01 dave
  !!    Added basic structure for PAO basis set
  !!   2011/06/15 13:04 dave
  !!    Added definition of WhichPulay before get_support_gradient call as check
  !!   2011/09/19 L.Tong
  !!    Added spin polarisation
  !!   2011/11/28 L.Tong
  !!    Removed redundant dependency on number_of_bands
  !!   2012/03/25 L.Tong
  !!   - Changed spin implementation
  !!   - removed redundant input parameter real(double) mu
  !!   2012/04/03 09:41 dave
  !!    Added code for analytic blip integrals
  !!  SOURCE
  !!
  subroutine pulay_force(p_force, KE_force, fixed_potential, vary_mu,  &
                         n_cg_L_iterations, L_tol, self_tol, &
                         total_energy, expected_reduction, n_atoms)

    use datatypes
    use logicals
    use numbers
    use primary_module,              only: bundle
    use matrix_module,               only: matrix, matrix_halo
    use matrix_data,                 only: mat, Srange, halo, blip_trans
    use mult_module,                 only: LNV_matrix_multiply,      &
                                           matM12,                   &
                                           allocate_temp_matrix,     &
                                           free_temp_matrix,         &
                                           return_matrix_value,      &
                                           matrix_pos,               &
                                           scale_matrix_value, ltrans, &
                                           matK, return_matrix_block_pos
    use global_module,               only: iprint_MD, WhichPulay,    &
                                           BothPulay, PhiPulay,      &
                                           SPulay, flag_basis_set,   &
                                           blips, PAOs, sf,          &
                                           flag_onsite_blip_ana,     &
                                           nspin, spin_factor,       &
                                           flag_analytic_blip_int, id_glob, species_glob
    use set_bucket_module,           only: rem_bucket, sf_sf_rem
    use blip_grid_transform_module,  only: blip_to_support_new,      &
                                           blip_to_grad_new
    use calc_matrix_elements_module, only: get_matrix_elements_new
    use S_matrix_module,             only: get_S_matrix, get_dS_analytic_oneL
    use H_matrix_module,             only: get_H_matrix
    use GenComms,                    only: gsum, cq_abort, mtime,    &
                                           inode, ionode
    use DiagModule,                  only: diagon
    use blip_gradient,               only: get_support_gradient
    use PAO_grid_transform_module,   only: PAO_to_grad
    use build_PAO_matrices,          only: assemble_deriv_2
    use cover_module,                only: BCS_parts
    use functions_on_grid,           only: supportfns,               &
                                           H_on_supportfns,          &
                                           allocate_temp_fn_on_grid, &
                                           free_temp_fn_on_grid
    use species_module,              only: nsf_species
    ! Temp
    use dimens,                      only: grid_point_volume,        &
                                           n_my_grid_points
    use density_module,              only: get_electronic_density,   &
                                           density
    use maxima_module,               only: maxngrid
    use comms_module,                ONLY: start_blip_transfer, fetch_blips
    use group_module,                ONLY: parts
    use blip,                        ONLY: blip_info
    use cover_module,                ONLY: BCS_parts
    use GenComms,                    ONLY: myid, cq_abort, my_barrier, mtime
    use mpi
    use support_spec_format,         ONLY: support_function, coefficient_array, &
                                           supports_on_atom
    implicit none

    ! Passed variables
    logical      :: vary_mu, fixed_potential
    integer      :: n_atoms
    integer      :: n_cg_L_iterations
    real(double) :: L_tol, self_tol, total_energy, expected_reduction
    real(double), dimension(3,n_atoms) :: p_force, KE_force

    ! Local variables
    logical      :: test
    integer      :: direction, count, nb, na, nsf1, point, place, i, &
                    neigh, ist, wheremat, jsf, gcspart, tmp_fn, n1,  &
                    n2, this_nsf, spin
    integer :: spec, icall, jpart, ind_part, j_in_halo, pb_len, nab
    integer :: j,jseq,specj,i_in_prim,speci, pb_st, nblipsj, nod, nsfj,sends,ierr
    integer :: neigh_global_num, neigh_global_part, neigh_species, neigh_prim, this_nsfi, this_nsfj
    integer, allocatable, dimension(:) :: nreqs

    real(double) :: energy_in, t0, t1
    real(double), dimension(nspin) :: electrons, energy_tmp
    real(double) :: dx, dy, dz, time0, time1
    real(double), allocatable, dimension(:), target :: part_blips
    type(support_function) :: supp_on_j
    integer, dimension(MPI_STATUS_SIZE) :: mpi_stat
    real(double), allocatable, dimension(:,:,:) :: this_data_K
    real(double), allocatable, dimension(:,:,:) :: this_data_M12
    real(double) :: forS, forKE

    ! Workarray for New Version
    !    I am not sure the present way for calculating p_force is the right way.
    !   Now, we calculate matrix elements data_tmp (= Sum_l phi_ialpha(rl)
    !   * psi_jbeta(rl)), whose off-diagonal elements are not needed.
    !   Then, calculate p_force from summing up diagonal elements of data_tmp.
    !    In the old version, every processor has to communicate with all other
    !   processors. The communication in the new version is local, but
    !   it calculates unneeded off-diagonal elements. Similar situation
    !   occurs in the normalisation of support functions at (initial_phis.f90)
    !    I am planning to implement the subroutine which only calculates
    !   the diagonal elements of matrix (=Sum_l phi_ialpha(rl) * psi_ialpha(rl))
    !   with local communication. (I am not sure it is important or not)
    !    --  02/Feb/2001  Tsuyoshi Miyazaki

    integer      :: iprim, np, ni, isf, mat_tmp
    real(double) :: matM12_value

    ! the force due to the change in T matrix elements is done differently...
    mat_tmp = allocate_temp_matrix(Srange, 0)
    if (inode == ionode .and. iprint_MD > 2) &
         write (io_lun, fmt='(4x,"Starting pulay_force()")')
    !p_force = zero

    ! first, lets make sure we have everything up to date. 
    ! Update H will give us support, S, K, H
    ! and h(local)_on_support [in workspace_support]

    ! This should be checked and changed: we don't want to do all this 
    ! again if we can avoid it !  Probably we will (a) have the data 
    ! already, or can (b) try get_SC_potl/get_new_rho or even just 
    ! get_H_matrix...
    test = .false.
    if (test) then
       ! (1) get S matrix
       call get_S_matrix(inode, ionode)
       ! (2) get K matrix
       if (.not. diagon) then
          call LNV_matrix_multiply(electrons, energy_tmp, doK, dontM1,&
                                   dontM2, dontM3, dontM4, dontphi, dontE)
       end if
       call get_electronic_density(density, electrons, supportfns,    &
                                   H_on_supportfns(1), inode, ionode, &
                                   maxngrid)
       ! H_on_supportfns is given the correct values after calls of
       ! get_H_matrix
       call get_H_matrix(.false., fixed_potential, electrons, density,&
                         maxngrid)
       if (.not. diagon) then
          call LNV_matrix_multiply(electrons, energy_tmp, dontK, doM1,&
                                   doM2, dontM3, dontM4, dontphi,     &
                                   dontE, mat_M12=matM12)
          ! note both Ne and E are not calculated here (dontphi
          ! and dontE)
       end if
    end if ! if (test)

    t0 = mtime()
    ! for the energy wrt support function we need  M1 and M2...
    ! If we're diagonalising, we've already build data_M12
    if (.not. diagon) then
       call LNV_matrix_multiply(electrons, energy_tmp, dontK, doM1,   &
                                doM2, dontM3, dontM4, dontphi, dontE, &
                                mat_M12=matM12)
    end if
    t1 = mtime()
    t0 = t1

    ! N.B. IT IS VITAL TO HAVE H_on_supportfns to storing the H (and
    ! corresponding spin down component) acting on support functions!

    ! Now we can evaluate support_gradient (into H_on_supportfns(1))
    ! If we are doing analytic on-site integrals, then zero the
    ! elements of M12 (the energy matrix) first
    if(flag_basis_set == blips .and. flag_analytic_blip_int) then
       allocate(nreqs(blip_trans%npart_send))
       ! For speed, we should have a blip_trans%max_len and max_nsf and allocate once
       time0 = mtime()
       call start_blip_transfer(nreqs,sends,parts%mx_ngonn)
       time1 = mtime()
       do jpart=1,halo(Srange)%np_in_halo
          pb_len = blip_trans%len_recv(jpart)
          ind_part = halo(Srange)%lab_hcell(jpart)
          nod = parts%i_cc2node(ind_part)
          ! Fetch remote blip coefficients for partition
          ! or copy local blip coefficients
          time0 = mtime()
          if(jpart>1) then
             if(ind_part/=halo(Srange)%lab_hcell(jpart-1)) then
                allocate(part_blips(pb_len))
                part_blips = zero
                if(nod==myid+1) then
                   pb_st = blip_trans%partst(parts%i_cc2seq(ind_part))
                   part_blips(1:pb_len) = coefficient_array(pb_st:pb_st+pb_len-1)
                else
                   call fetch_blips(part_blips,pb_len,nod-1,(myid)*parts%mx_ngonn + parts%i_cc2seq(ind_part))
                end if
             end if
          else
             allocate(part_blips(pb_len))
             part_blips = zero
             if(nod==myid+1) then
                pb_st = blip_trans%partst(parts%i_cc2seq(ind_part))
                part_blips(1:pb_len) = coefficient_array(pb_st:pb_st+pb_len-1)
             else
                call fetch_blips(part_blips,pb_len,nod-1,(myid)*parts%mx_ngonn + parts%i_cc2seq(ind_part))
             end if
          endif
          time1 = mtime()
          gcspart = halo(Srange)%i_hbeg(halo(Srange)%lab_hcover(jpart))
          pb_st = 1
          time0 = mtime()
          do j=1,halo(Srange)%nh_part(jpart) ! Loop over atoms j in partition
             j_in_halo = halo(Srange)%j_beg(jpart)+j-1
             jseq = halo(Srange)%j_seq(j_in_halo)
             specj = species_glob( id_glob( parts%icell_beg(halo(Srange)%lab_hcell(jpart))+jseq-1) )
             nblipsj = blip_info(specj)%NBlipsRegion
             this_nsfj = nsf_species(specj)
             allocate(supp_on_j%supp_func(this_nsfj))
             do nsfj=1,this_nsfj
                supp_on_j%supp_func(nsfj)%ncoeffs = nblipsj
                supp_on_j%supp_func(nsfj)%coefficients => part_blips(pb_st:pb_st+nblipsj-1)
                pb_st = pb_st+nblipsj
             end do
             do i=1,ltrans(Srange)%n_hnab(j_in_halo) ! Loop over atoms i: primary set neighbours of j
                i_in_prim=ltrans(Srange)%i_prim(ltrans(Srange)%i_beg(j_in_halo)+i-1)
                speci = bundle%species(i_in_prim)
                this_nsfi = nsf_species(speci)
                dx = BCS_parts%xcover(gcspart+jseq-1)-bundle%xprim(i_in_prim)
                dy = BCS_parts%ycover(gcspart+jseq-1)-bundle%yprim(i_in_prim)
                dz = BCS_parts%zcover(gcspart+jseq-1)-bundle%zprim(i_in_prim)
                if((dx*dx + dy*dy + dz*dz)>very_small) then
                   allocate(this_data_K(this_nsfi,this_nsfj,nspin),this_data_M12(this_nsfi,this_nsfj,nspin))
                   this_data_K = zero
                   this_data_M12 = zero
                   do spin=1,nspin
                      wheremat = matrix_pos(matK(spin),i_in_prim,j_in_halo,1,1)
                      call return_matrix_block_pos(matK(spin),wheremat,this_data_K(:,:,spin),this_nsfi*this_nsfj)
                      wheremat = matrix_pos(matM12(spin),i_in_prim,j_in_halo,1,1)
                      call return_matrix_block_pos(matM12(spin),wheremat,this_data_M12(:,:,spin),this_nsfi*this_nsfj)
                   end do
                   do direction = 1,3
                      call get_dS_analytic_oneL(supports_on_atom(i_in_prim),supp_on_j, &
                           forS,forKE,this_data_M12,this_data_K, i_in_prim, &
                           j_in_halo,dx,dy,dz,speci,specj,this_nsfi,this_nsfj,direction)
                      p_force(direction,bundle%ig_prim(i_in_prim)) = p_force(direction,bundle%ig_prim(i_in_prim)) &
                           - forS!(direction)
                      KE_force(direction,bundle%ig_prim(i_in_prim)) = KE_force(direction,bundle%ig_prim(i_in_prim)) &
                           - forKE!(direction)
                   end do
                   deallocate(this_data_M12,this_data_K)
                end if
             end do
             do nsfj=1,this_nsfj
                nullify(supp_on_j%supp_func(nsfj)%coefficients)
             end do
             deallocate(supp_on_j%supp_func)
          end do
          if(jpart<halo(Srange)%np_in_halo) then
             if(ind_part/=halo(Srange)%lab_hcell(jpart+1)) then
                deallocate(part_blips)
             end if
          else
             deallocate(part_blips)
          end if
          time1 = mtime()
       end do
       if(sends>0) then
          do i=1,sends
             call MPI_Wait(nreqs(i),mpi_stat,ierr)
             if(ierr/=0) call cq_abort("Error waiting for blip send to finish",i)
          end do
       end if
       call my_barrier
       deallocate(nreqs)
       WhichPulay = PhiPulay
    else
       if (flag_basis_set == blips .and. flag_onsite_blip_ana) then
          iprim = 0
          do np = 1, bundle%groups_on_node
             do ni = 1, bundle%nm_nodgroup(np)
                iprim = iprim+1
                this_nsf = nsf_species(bundle%species(iprim))
                do n1 = 1, this_nsf
                   do n2 = 1, this_nsf
                      do spin = 1, nspin
                         call scale_matrix_value(matM12(spin), np, ni, &
                              iprim, 0, n1, n2, zero, 1)
                      end do ! spin
                   end do ! n2
                end do ! n1
             end do ! ni
          end do ! np
       end if
       WhichPulay = BothPulay
    end if
    call get_support_gradient(H_on_supportfns(1), inode, ionode)

    t1 = mtime()
    if (inode == ionode .and. iprint_MD > 3) then
       write (io_lun, fmt='(4x,"get_support_gradient time: ",f12.5)') &
             t1 - t0
    end if
    t0 = t1
    
    if (WhichPulay == BothPulay .or. WhichPulay == PhiPulay .or. &
        (WhichPulay == SPulay .and. flag_basis_set == blips)) then
       tmp_fn = allocate_temp_fn_on_grid(sf)
       ! now for each direction in turn
       do direction = 1, 3
          ! we get the grad of the support functions
          if (flag_basis_set == blips) then
             call blip_to_grad_new(inode-1, direction, tmp_fn)
          else if (flag_basis_set == PAOs) then
             call PAO_to_grad(inode-1, direction, tmp_fn)
          else
             call cq_abort("pulay_force: basis set undefined ", flag_basis_set)
          end if
          t1 = mtime()
          if (inode == ionode .and. iprint_MD > 3)&
               write (io_lun, fmt='(10x,"Phi Pulay grad ",i4," time: ",f12.5)')&
                     direction, t1 - t0
          t0 = t1
          
          !       ! and do the integration
          !       count = 0
          !       ! loop over all grid points
          !       do nb = 1, n_blocks
          !       ! loop over support regions on this grid point
          !          do na = 1, n_atoms_block(nb)
          !             i = atoms_block(nb, na)
          !             ! loop over support functions
          !             do nsf1 = 1, nsf
          !                ! loop over points in block
          !                do point = 1, n_pts_in_block
          !                   place = count + point
          !                   p_force(direction,i) = p_force(direction,i) - &
          !                        workspace_support(place) * &
          !                        workspace2_support(place) * &
          !                        grid_point_volume
          !                end do
          !                count = count + n_pts_in_block
          !             end do
          !          end do
          !       end do
          !    end do
          !    !sum contributions from all nodes
          !    call gsum(p_force,3,n_atoms)

          ! H_on_support(1) now stores the gradient of TOTAL E with
          ! respect to supportfuns
          call get_matrix_elements_new(inode-1, rem_bucket(sf_sf_rem),&
                                       mat_tmp, H_on_supportfns(1), tmp_fn)
          t1 = mtime()
          if (inode == ionode .and. iprint_MD > 3) &
               write (io_lun, fmt='(10x,"Phi Pulay int ",i4," time: ",f12.5)')&
                     direction, t1 - t0
          t0 = t1

          ! now store calculated values to p_force
          iprim = 0
          call start_timer(tmr_std_matrices)
          do np = 1, bundle%groups_on_node
             if (bundle%nm_nodgroup(np) > 0) then
                do ni = 1, bundle%nm_nodgroup(np)
                   iprim = iprim + 1
                   !i=id_glob(index_my_atoms(iprim))
                   !i=index_my_atoms(iprim)
                   i = bundle%ig_prim(iprim)
                   do isf = 1, nsf_species(bundle%species(iprim))
                      p_force(direction, i) = &
                           p_force(direction, i) - &
                           return_matrix_value(mat_tmp, np, ni, 0, 0, &
                                               isf, isf, 1)
                      ! The factor of grid_point_volume is already
                      !  included
                      ! in get_matrix_elements
                   end do ! isf
                end do ! ni
             end if ! if the partition has atoms
          end do ! np
          call stop_timer(tmr_std_matrices)
          t1 = mtime()
          if (inode == ionode .and. iprint_MD > 3) &
               write (io_lun, fmt='(10x,"Phi Pulay sum ",i4," time: ",f12.5)')&
                     direction, t1-t0
          t0 = t1
       end do ! direction
       call free_temp_fn_on_grid(tmp_fn)
    end if ! if (WhichPulay == BothPulay .OR. WhichPulay == PhiPulay .OR.&
           !  & (WhichPulay == SPulay .AND. flag_basis_set == blips)) then
    
    if (flag_basis_set == PAOs .and. &
        (WhichPulay == BothPulay .or. WhichPulay == SPulay)) then 
       ! We need to do the S-pulay term
       ! now for each direction in turn
       do direction = 1, 3
          ! Call assemble to generate dS_ij/dR_kl
          call assemble_deriv_2(direction, Srange, mat_tmp, 1)
          ! For each primary set atom, we want \sum_j dS_ij G_ij (I think)
          iprim = 0
          call start_timer(tmr_std_matrices)
          do np = 1, bundle%groups_on_node
             if (bundle%nm_nodgroup(np) > 0) then
                do ni = 1, bundle%nm_nodgroup(np)
                   iprim = iprim + 1
                   !i=id_glob(index_my_atoms(iprim))
                   !i=index_my_atoms(iprim)
                   i = bundle%ig_prim(iprim)
                   do neigh = 1, mat(np,Srange)%n_nab(ni)
                      ist = mat(np,Srange)%i_acc(ni) + neigh - 1
                      gcspart = &
                           BCS_parts%icover_ibeg(mat(np,Srange)%i_part(ist)) + &
                           mat(np,Srange)%i_seq(ist) - 1
                      ! matM12(1) here is just used to work out the
                      ! position in matrix, this position will be
                      ! identical for matM12(nspin), so only matM12(1)
                      ! needed here
                      wheremat = matrix_pos(matM12(1), iprim,             &
                                            halo(Srange)%i_halo(gcspart), &
                                            1, 1)
                      if (wheremat /= mat(np,Srange)%onsite(ni)) then
                         do isf = 1, mat(np,Srange)%ndimj(ist)
                            do jsf = 1, mat(np,Srange)%ndimi(ni)
                               matM12_value = zero
                               do spin = 1, nspin
                                  matM12_value =                                 &
                                       matM12_value + spin_factor *              &
                                       return_matrix_value(matM12(spin), np, ni, &
                                                           iprim, neigh, jsf, isf)
                               end do ! spin
                               ! the factor of two here comes from
                               ! chain rule in derivatives of K
                               ! respect to phi
                               p_force(direction,i) =                    &
                                    p_force(direction,i) +               &
                                    two * matM12_value *                 &
                                    return_matrix_value(mat_tmp, np, ni, &
                                                        iprim, neigh, jsf, isf)
                            end do ! jsf
                         end do ! isf
                      end if ! (wheremat /= mat(np,Srange)%onsite(ni))
                   end do ! neigh
                end do ! ni
             end if ! (bundle%nm_nodgroup(np) > 0)
          end do ! np
          call stop_timer(tmr_std_matrices)
          t1 = mtime ()
          if (inode == ionode .AND. iprint_MD > 3) &
               write (io_lun,*) 'S Pulay ', direction, ' time: ', t1 - t0
          t0 = t1
       end do ! direction
    end if

    !  In principle, the summation below is not needed.
    !  p_force should be calculated only for my primary set of atoms.
    call gsum(p_force, 3, n_atoms)
    if(flag_analytic_blip_int) call gsum (KE_force, 3, n_atoms)
    call free_temp_matrix(mat_tmp)

    return
  end subroutine pulay_force
  !!***

! -----------------------------------------------------------
! Subroutine get_HF_force
! -----------------------------------------------------------

!!****f* force_module/get_HF_force *
!!
!!  NAME 
!!   get_HF_force
!!  USAGE
!! 
!!  PURPOSE
!!   Gets the Hellman-Feynman contribution to the 
!!   atomic forces. For this both the electron density
!!   and Hartree potential are needed.
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   E.H.Hernandez
!!  CREATION DATE
!!   Summer 1995
!!  MODIFICATION HISTORY
!!   12/9/95 by Chris Goringe to use new data distribution
!!   22/1/96 by EH to correct.
!!   24/4/96 by EH to adapt to new data structure.
!!   27/11/97 by DRB to correct expressions
!!   21/05/2001 dave
!!    Added ROBODoc header, converted to F90 and stripped
!!    subroutine calls
!!   08/06/2001 dave
!!    Changed to use gsum from GenComms and added RCS Id
!!    and Log tags
!!   12/06/2001 dave
!!    Included in force_module
!!   2004/10/05 drb
!!    Added hartree_module use
!!   2008/03/03 18:46 dave
!!    Changed float to real
!!  TODO
!!    Fix this so that it doesn't loop over all processors ! Follow
!!    set_pseudo 13/05/2002 dave
!!  SOURCE
!!
  subroutine get_HF_force(hf_force, density, n_atoms, size)

    use datatypes
    use numbers
    use dimens, only: n_my_grid_points, x_grid, y_grid, z_grid, &
         grid_point_volume, r_super_x, r_super_y, r_super_z
    use grid_index, only: grid_point_block, grid_point_x, &
         grid_point_y, grid_point_z
    use species_module, only: species, charge
    use pseudopotential_data, only: ps_exponent, core_radius_2, &
         radius_max, n_points_max, local_pseudopotential, &
         d2_local_pseudopotential
    use global_module, only: rcellx,rcelly,rcellz,id_glob, &
         species_glob, nlpf, ni_in_cell
    use block_module, only : nx_in_block,ny_in_block,nz_in_block, &
         n_pts_in_block
    use group_module, only : blocks, parts
    use primary_module, only: domain
    use cover_module, only: DCS_parts
    use set_blipgrid_module, only : naba_atm
    use GenComms, only: my_barrier, cq_abort, inode, ionode, gsum
    use hartree_module, only: hartree
    use maxima_module, only: maxngrid

    implicit none

    ! Passed variables
    integer :: n_atoms, size

    real(double), dimension(:,:) :: hf_force 
    real(double), dimension(:) :: density

    ! Local variables
    integer :: i, j, my_block, n, the_species, iatom

    real(double) :: a, b, da, db, dc, dd, r, alpha, beta, derivative, &
         fx_1, fx_2, fy_1, fy_2, fz_1, fz_2, gauss, h_energy, rx, ry, &
         rz, x_point, y_point, z_point, r2, r_from_i, x, y, z, step, &
         q, elec_here, local_potential, c, d

    real(double):: dcellx_block, dcelly_block, dcellz_block
    real(double):: dcellx_grid, dcelly_grid, dcellz_grid
    integer :: ipart, jpart, ind_part, ia, ii, icover, ig_atom
    real(double):: xatom, yatom, zatom
    real(double):: xblock, yblock, zblock
    real(double) :: dx, dy, dz
    integer :: ix, iy, iz, iblock, ipoint, igrid

    ! Automatic
    real(double) :: h_potential(size) 

!    the_species = 1
!    step = radius_max(1)/real(n_points_max(1)-1,double)
!    do i=1,n_points_max(1)-1
!       r = i*step+0.5*step
!       a = ( real(i+1,double)*step - r ) / step
!       b = one - a
!       c = a * ( a * a - one ) * step * step / six
!       d = b * ( b * b - one ) * step * step / six
!       da = -one / step
!       db =  one / step
!       dc = -step * ( three * a * a - one ) / six
!       dd =  step * ( three * b * b - one ) / six
!       local_potential =   &
!            a * local_pseudopotential(i,the_species)+  &
!            b * local_pseudopotential(i+1,the_species)+ &
!            c * d2_local_pseudopotential(i,the_species)+  &
!            d * d2_local_pseudopotential(i+1,the_species)
!       derivative =  &
!            da * local_pseudopotential(i,the_species) +  &
!            db * local_pseudopotential(i+1,the_species) + &
!            dc * d2_local_pseudopotential(i,the_species) +  &
!            dd * d2_local_pseudopotential(i+1,the_species)
!    end do

    ! get Hartree potential
    HF_force = zero
    
    call hartree (density, h_potential, maxngrid, h_energy)

    dcellx_block = rcellx / blocks%ngcellx
    dcelly_block = rcelly / blocks%ngcelly
    dcellz_block = rcellz / blocks%ngcellz
    
    dcellx_grid = dcellx_block / nx_in_block
    dcelly_grid = dcelly_block / ny_in_block    
    dcellz_grid = dcellz_block / nz_in_block
    
    call my_barrier()

    do iblock = 1, domain%groups_on_node ! primary set of blocks
       xblock = (domain%idisp_primx(iblock) + domain%nx_origin - 1) *&
            & dcellx_block
       yblock = (domain%idisp_primy(iblock) + domain%ny_origin - 1) *&
            & dcelly_block
       zblock = (domain%idisp_primz(iblock) + domain%nz_origin - 1) *&
            & dcellz_block

       if (naba_atm(nlpf)%no_of_part(iblock) > 0) then ! if there are naba atoms
          iatom = 0
          do ipart = 1, naba_atm(nlpf)%no_of_part(iblock)
             jpart = naba_atm(nlpf)%list_part(ipart, iblock)
             if(jpart > DCS_parts%mx_gcover) then 
                call cq_abort ('set_ps: JPART ERROR ', ipart, jpart)
             end if
             ind_part = DCS_parts%lab_cell(jpart)
             do ia = 1, naba_atm(nlpf)%no_atom_on_part(ipart, iblock)
                iatom = iatom + 1
                ii = naba_atm(nlpf)%list_atom(iatom, iblock)
                icover = DCS_parts%icover_ibeg(jpart) + ii - 1
                ig_atom = id_glob(parts%icell_beg(ind_part) + ii - 1)
                if (parts%icell_beg(ind_part) + ii-1 > ni_in_cell) then
                   call cq_abort ('set_ps: globID ERROR ',&
                        & ii, parts %icell_beg(ind_part))
                end if
                if (icover > DCS_parts%mx_mcover) then
                   call cq_abort ('set_ps: icover ERROR ',&
                        & icover, DCS_parts%mx_mcover)
                end if
                xatom = DCS_parts%xcover(icover)
                yatom = DCS_parts%ycover(icover)
                zatom = DCS_parts%zcover(icover)
                ! the_species = species(ig_atom)
                the_species = species_glob(ig_atom)
                q = charge(the_species)
                alpha = ps_exponent(the_species)
                beta = (alpha / pi)**1.5_double * grid_point_volume
                step = radius_max(the_species) /&
                     & real (n_points_max(the_species)-1, double)
                ipoint = 0
                do iz = 1, nz_in_block
                   do iy = 1, ny_in_block
                      do ix = 1, nx_in_block
                         ipoint = ipoint + 1
                         igrid = n_pts_in_block * (iblock-1) + ipoint
                         if (igrid > n_my_grid_points) then
                            call cq_abort ('set_ps: igrid error ',&
                                 & igrid, n_my_grid_points)
                         end if
                         elec_here = density(igrid) * grid_point_volume
                         dx = dcellx_grid * (ix-1)
                         dy = dcelly_grid * (iy-1)
                         dz = dcellz_grid * (iz-1)
                         rx = xblock + dx - xatom
                         ry = yblock + dy - yatom
                         rz = zblock + dz - zatom
                         r2 = rx * rx + ry * ry + rz * rz
                         gauss = exp (-alpha * r2)
                         if (r2 < core_radius_2(the_species)) then
                            r_from_i = sqrt( r2 )
                            !if ( r_from_i > zero ) then
                            if (r_from_i > very_small) then
                               x = rx / r_from_i
                               y = ry / r_from_i
                               z = rz / r_from_i
                            else
                               x = zero
                               y = zero
                               z = zero
                            end if
                            j = aint (r_from_i / step) + 1
                            ! check j
                            if (j > n_points_max(the_species) - 1) then
                               call cq_abort ('set_ps: overrun problem', j)
                            end if
                            r = real (j, double) * step
                            a = (r - r_from_i) / step
                            b = one - a
                            da = -one / step
                            db =  one / step
                            dc = -step * (three * a * a - one) / six
                            dd =  step * (three * b * b - one) / six
                            derivative = da * &
                                 local_pseudopotential(j, &
                                 the_species) + db * &
                                 local_pseudopotential(j + 1, &
                                 the_species) + dc * &
                                 d2_local_pseudopotential(j, &
                                 the_species) + dd * &
                                 d2_local_pseudopotential(j + 1, &
                                 the_species)
                            ! This is a little obscure, but the
                            ! multiples below have had the minus sign
                            ! which should be there removed to correct
                            ! an earlier on dropped in the da, db, dc,
                            ! dd expressions.DRB 27.11.97
                            fx_1 = x * derivative
                            fy_1 = y * derivative 
                            fz_1 = z * derivative 
                            fx_2 = two * alpha * beta * rx * gauss * &
                                   h_potential(igrid) * q
                            fy_2 = two * alpha * beta * ry * gauss * &
                                   h_potential(igrid) * q
                            fz_2 = two * alpha * beta * rz * gauss * &
                                   h_potential(igrid) * q
                         else
                            fx_1 = zero
                            fy_1 = zero
                            fz_1 = zero
                            fx_2 = zero
                            fy_2 = zero
                            fz_2 = zero
                         end if ! if (r2 < core_radius_2(the_species)) then
                         HF_force(1,ig_atom) = HF_force(1,ig_atom) + &
                                fx_1 * elec_here 
                         HF_force(2,ig_atom) = HF_force(2,ig_atom) + &
                                fy_1 * elec_here
                         HF_force(3,ig_atom) = HF_force(3,ig_atom) + &
                                fz_1 * elec_here
                         HF_force(1,ig_atom) = HF_force(1,ig_atom) + &
                                fx_2
                         HF_force(2,ig_atom) = HF_force(2,ig_atom) + &
                                fy_2
                         HF_force(3,ig_atom) = HF_force(3,ig_atom) + &
                                fz_2
                      end do !ix
                   end do  !iy
                end do   !iz
             end do ! naba_atoms
          end do ! naba_part
       end if !(naba_atm(nlpf)%no_of_part(iblock) > 0) !naba atoms?
    end do ! iblock : primary set of blocks
    
!    ! now loop over grid points and accumulate HF part of the force
!    do n=1, n_my_grid_points
!       my_block = grid_point_block(n)
!       elec_here = density(n) * grid_point_volume
!       x_point = (grid_point_x(n) - 1) * x_grid
!       y_point = (grid_point_y(n) - 1) * y_grid
!       z_point = (grid_point_z(n) - 1) * z_grid
!       do i=1, n_atoms
!          q = charge(species(i))
!          alpha = exponent(species(i))
!          beta = (alpha / pi)**1.5_double * grid_point_volume
!          rx = ( x_point - rionx(i) ) 
!          ry = ( y_point - riony(i) )
!          rz = ( z_point - rionz(i) )
!          rx = rx - anint(rx)
!          ry = ry - anint(ry)
!          rz = rz - anint(rz)
!          rx = rx * r_super_x
!          ry = ry * r_super_y
!          rz = rz * r_super_z
!          r2 = rx * rx + ry * ry + rz * rz
!          gauss = dexp( -alpha * r2 )
!          if ( r2 .lt. core_radius_2(species(i)) ) then
!             r_from_i = sqrt( r2 )
!             if ( r_from_i .gt. zero ) then
!                x = rx / r_from_i
!                y = ry / r_from_i
!                z = rz / r_from_i
!             else
!                x = zero
!                y = zero
!                z = zero
!             end if
!             ! now we construct the derivative of the local part of the 
!             ! pseudopotential by spline interpolation from a table
!             step = radius_max(species(i)) / &
!                  real( n_points_max(species(i)) - 1, double)
!             j = aint( r_from_i / step ) + 1
!
!             ! with this we can now use the spline interpolation tables to 
!             ! construct the derivative of the local part of the 
!             ! pseudopotential on the grid
!             r = real(j,double) * step
!             a = ( r - r_from_i ) / step
!             b = one - a
!             da = -one / step
!             db =  one / step
!             dc = -step * ( three * a * a - one ) / six
!             dd =  step * ( three * b * b - one ) / six
!             derivative =  &
!                  da * local_pseudopotential(j,species(i)) +  &
!                  db * local_pseudopotential(j+1,species(i)) + &
!                  dc * d2_local_pseudopotential(j,species(i)) +  &
!                  dd * d2_local_pseudopotential(j+1,species(i))
!
!             ! This is a little obscure, but the multiples below have had 
!             ! the minus sign which should be there removed to correct an 
!             ! earlier on dropped in the da, db, dc, dd expressions.DRB 27.11.97
!             fx_1 = x * derivative
!             fy_1 = y * derivative 
!             fz_1 = z * derivative 
!             fx_2 = two * alpha * beta * rx * gauss * h_potential( n ) * q
!             fy_2 = two * alpha * beta * ry * gauss * h_potential( n ) * q
!             fz_2 = two * alpha * beta * rz * gauss * h_potential( n ) * q
!          else
!             fx_1 = zero
!             fy_1 = zero
!             fz_1 = zero
!             fx_2 = zero
!             fy_2 = zero
!             fz_2 = zero
!          end if
!          HF_force(1,i) = HF_force(1,i) + fx_1 * elec_here 
!          HF_force(2,i) = HF_force(2,i) + fy_1 * elec_here
!          HF_force(3,i) = HF_force(3,i) + fz_1 * elec_here
!!            fx_2 = two * alpha * beta * rx * gauss * h_potential( n ) * q
!!            fy_2 = two * alpha * beta * ry * gauss * h_potential( n ) * q
!!            fz_2 = two * alpha * beta * rz * gauss * h_potential( n ) * q
!          HF_force(1,i) = HF_force(1,i) + fx_2
!          HF_force(2,i) = HF_force(2,i) + fy_2
!          HF_force(3,i) = HF_force(3,i) + fz_2
!       end do
!    end do

    ! and add contributions from all nodes
!    do i = 1, n_atoms
!       write(io_lun,*) inode,i,(HF_force(j,i),j=1,3)
!    end do
    call gsum (HF_force, 3, n_atoms)
!    do i = 1, n_atoms
!       write(io_lun,*) inode,i,(HF_force(j,i),j=1,3)
!    end do

    return    
  end subroutine get_HF_force
!!***

  ! -----------------------------------------------------------
  ! Subroutine get_HF_non_local_force
  ! -----------------------------------------------------------
  
  !!****f* force_module/get_HF_non_local_force *
  !!
  !!  NAME 
  !!   get_HF_non_local_force
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Gets the non-local part of the HF force
  !! 
  !!   There is a little wrangling about this - it's not entirely clear
  !!   whether it's a Hellmann-Feynman force or a Pulay force. Whatever 
  !!   it's called, it is due to the change in the support/projector 
  !!   overlap matrix with no dependence on the charge density.
  !!  INPUTS
  !! 
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   E.H.Hernandez
  !!  CREATION DATE
  !!   29/4/96 
  !!  MODIFICATION HISTORY
  !!   24/2/97 CMG 
  !!    We no longer carry grad support around, it needs to be generated on the fly
  !!   04/09/2000 TM
  !!    new get_matrix_elements  
  !!   15/01/2001 TM
  !!    new blip_to_grad  
  !!   11/05/01 and 14/05/01 DRB
  !!    Removed many of the arguments passed and redundant local variables
  !!   17/05/2001 dave
  !!    Changed subroutine call to blip_to_grad
  !!   21/05/2001 dave
  !!    Reduced subroutine call and use statements
  !!   22/05/2001 dave
  !!    Added more discussion to the PURPOSE comment field
  !!   11/06/2001 dave
  !!    Added RCS Id and Log tags and GenComms
  !!   11/06/2001 dave
  !!    Corrected to add data_U finding lines (required for correct forces)
  !!   12/06/2001 dave
  !!    Included in force_module
  !!   21/06/2001 dave
  !!    Removed use matrix_diag (now in this module)
  !!    Removed matrix_scaling
  !!   14:20, 02/09/2003 drb 
  !!    Added flag to select HF or Pulay or both (for easier force testing)
  !!   08:12, 2003/10/01 dave
  !!    Added structure to prepare for PAO basis set
  !!   2011/11/22 L.Tong
  !!    Added spin polarisation
  !!    - changed the definition of HF_NL_force to be more aligned to
  !!      F90 syntax style and as an assumed shape array
  !!   2011/12/12 17:26 dave
  !!    Added force calculation for analytic blips
  !!   2012/03/26 L.Tong
  !!   - Changed spin implementation
  !!  SOURCE
  !!
  subroutine get_HF_non_local_force(HF_NL_force, what_force, n_atoms)

    use datatypes
    use numbers
    use dimens
    use GenBlas
    use matrix_data,                 only: SPrange, PSrange, mat, halo
    use mult_module,                 only: SP_trans, mult, H_SP_SP,    &
                                           matrix_product,             &
                                           matrix_scale,               &
                                           matrix_transpose,           &
                                           allocate_temp_matrix,       &
                                           free_temp_matrix, matU,     &
                                           matUT, matCS, matSC, matK
    use species_module,              only: species
    use pseudopotential_data,        only: pseudopotential_derivatives
    use set_bucket_module,           only: rem_bucket, sf_nlpf_rem
    use calc_matrix_elements_module, only: get_matrix_elements_new
    use blip_grid_transform_module,  only: blip_to_grad_new
    use GenComms,                    only: gsum, cq_abort, inode,      &
                                           ionode
    ! TM new pseudo
    use pseudopotential_common,      only: pseudo_type, OLDPS, SIESTA, &
                                           STATE, ABINIT
    use pseudo_tm_module,            only: nonloc_pp_derivative_tm
    use global_module,               only: iprint_MD, flag_basis_set,  &
                                           blips, PAOs, sf, nlpf,      &
                                           nspin, spin_factor,         &
                                           id_glob, species_glob,      &
                                           flag_analytic_blip_int
    ! TEMP
    use PAO_grid_transform_module,   only: PAO_to_grad
    use build_PAO_matrices,          only: assemble_deriv_2
    use group_module,                only: parts
    use primary_module,              only: bundle
    use cover_module,                only: BCS_parts
    use GenComms,                    only: gsum, myid
    use functions_on_grid,           only: allocate_temp_fn_on_grid,   &
                                           free_temp_fn_on_grid,       &
                                           supportfns,                 &
                                           H_on_supportfns, pseudofns
    use nlpf2blip,                   only: get_dSP, nlpf_on_atom
    use primary_module ,             only: bundle
    use support_spec_format,         only: supports_on_atom
    use group_module,                only: parts
    use primary_module,              only: bundle
    use cover_module,                only: BCS_parts
    use species_module,              only: nsf_species, nlpf_species

    implicit none

    ! Passed variables
    integer :: n_atoms, what_force
    real(double), dimension(:,:) :: HF_NL_force

    ! Local variables

    ! data_dCS will be obtained by a global trans of data_dCS_t
    !  this trans is same as the one used in U => UT
    !     Tsuyoshi Miyazaki 28/12/2000
    integer, dimension(3) :: matdSC, matdCS
    integer      :: direction, k, stat, dpseudofns, np, nn, i, i1, i2, &
                    spec, this_nsf, this_nlpf, ni, spin
    integer      :: iprim, gcspart, ist, nab, neigh_global_num,        &
                    neigh_global_part, neigh_species, wheremat
    real(double) :: dx, dy, dz

    do k = 1, 3
       matdSC(k) = allocate_temp_matrix (SPrange, SP_trans, sf, nlpf)
       matdCS(k) = allocate_temp_matrix (PSrange, SP_trans, nlpf, sf)
    end do
    if (flag_basis_set == blips .and. (.not. flag_analytic_blip_int)) then
       dpseudofns = allocate_temp_fn_on_grid(nlpf)
    end if
    HF_NL_force = zero

    ! to save memory we do each direction in turn...
    do direction = 1, 3
       call matrix_scale(zero, matdSC(direction))
       call matrix_scale(zero, matdCS(direction))
       if ((flag_basis_set == blips) .and. flag_analytic_blip_int) then
          iprim=0
          do np = 1, bundle%groups_on_node
             if (bundle%nm_nodgroup(np) > 0) then
                do ni = 1, bundle%nm_nodgroup(np)
                   iprim = iprim + 1
                   spec = bundle%species(iprim)
                   ! Loop over neighbours of atom
                   do nab = 1, mat(np,SPrange)%n_nab(ni)
                      ist = mat(np,SPrange)%i_acc(ni) + nab - 1
                      ! Build the distances between atoms - needed for phases 
                      gcspart = &
                           BCS_parts%icover_ibeg(mat(np,SPrange)%i_part(ist)) + &
                           mat(np,SPrange)%i_seq(ist) - 1
                      ! Displacement vector
                      dx = BCS_parts%xcover(gcspart) - bundle%xprim(iprim)
                      dy = BCS_parts%ycover(gcspart) - bundle%yprim(iprim)
                      dz = BCS_parts%zcover(gcspart) - bundle%zprim(iprim)
                      ! We need to know the species of neighbour
                      neigh_global_part = &
                           BCS_parts%lab_cell(mat(np,SPrange)%i_part(ist)) 
                      neigh_global_num  = &
                           id_glob(parts%icell_beg(neigh_global_part) + &
                                   mat(np,SPrange)%i_seq(ist) - 1)
                      neigh_species = species_glob(neigh_global_num)
                      if ((dx*dx + dy*dy + dz*dz) > very_small) then
                         call get_dSP(supports_on_atom(iprim),         &
                                      nlpf_on_atom(neigh_species),     &
                                      matdSC(direction), iprim,        &
                                      halo(SPrange)% i_halo(gcspart),  &
                                      dx, dy, dz, spec, neigh_species, &
                                      direction)
                      end if
                   end do ! nab
                end do ! ni
             end if ! (bundle%nm_nodgroup(np) > 0)
          end do ! np
          call matrix_transpose(matdSC(direction), matdCS(direction))
          call matrix_scale(-one, matdSC(direction))
       else if (flag_basis_set == blips .and. &
                (.not. flag_analytic_blip_int)) then
          ! first of all construct the directional derivatives of the core
          ! functions on the grid
          select case (pseudo_type)
          case (OLDPS)
             call pseudopotential_derivatives(direction, dpseudofns)
          case (SIESTA)
             call nonloc_pp_derivative_tm(direction, dpseudofns)
          case (ABINIT)
             call nonloc_pp_derivative_tm(direction, dpseudofns)
          end select
          !if(direction.eq.3) then
          !   stop
          !else
          !   continue
          !end if
          ! now calculate overlap between these derivatives and support functions 
          ! New get_matrix_elements  TSUYOSHI MIYAZAKI 28/Dec/2000
          call get_matrix_elements_new(inode-1,                       &
                                       rem_bucket(sf_nlpf_rem),       &
                                       matdSC(direction), supportfns, &
                                       dpseudofns)
          call matrix_transpose(matdSC(direction), matdCS(direction))
          call matrix_scale(-one, matdCS(direction))
          ! and the overlap between the derivatives of the support and
          ! the core functions, H_on_supportfns(1) is used as a work array
          call blip_to_grad_new(inode-1, direction, H_on_supportfns(1))
          call get_matrix_elements_new(inode-1,                 &
                                       rem_bucket(sf_nlpf_rem), &
                                       matdSC(direction),       &
                                       H_on_supportfns(1),      &
                                       pseudofns)
          call matrix_scale(-one, matdSC(direction))
          ! actually, because the derivatives we want are with respect to the
          ! position of the atom supporting each support function, we must
          ! scale the above integrals by -1
       else if (flag_basis_set == PAOs) then
          ! Get matrix elements between derivative of projectors and
          ! support functions
          call assemble_deriv_2(direction, SPrange, matdSC(direction), 3)
          call matrix_scale(-one, matdSC(direction))
          
          ! Get matrix elements between projectors and derivative of
          ! support functions BY TRANSPOSE. This is fine (I think)
          ! because the transpose ought to be exact
          call matrix_transpose(matdSC(direction), matdCS(direction))
          call matrix_scale(-one, matdCS(direction))
       else
          call cq_abort("get_HF_NL_force: basis set undefined ", &
                        flag_basis_set)
       end if ! ((flag_basis_set == blips) .and. flag_analytic_blip_int)
    end do ! Now end the direction loop
    if (flag_basis_set == blips .and. (.not.flag_analytic_blip_int)) &
         call free_temp_fn_on_grid(dpseudofns)
    ! First of all, find U (= K.SC)
    call matrix_transpose(matSC, matCS)
    do spin = 1, nspin
       call matrix_product(matK(spin), matCS, matU(spin), mult(H_SP_SP))
       ! we factor matU(1) with spin_factor for spin non-polarised
       ! calculation. This may cause slight confusion, as the factor
       ! are not applied to other matrices of the spin channels, and
       ! matU(1) is supposed to be U for spin up, but doing this way
       ! we make the calculations more efficient.
       call matrix_scale(minus_two * spin_factor, matU(spin))
       ! Find the transpose of U (= K.SC)
       call matrix_transpose(matU(spin), matUT(spin))
    end do

    ! For PAOs, we need to zero the on-site terms

    ! Evaluate the pulay term - due to the phis changing
    ! NB We want sum_k dSC_ik.UT_ki, so let's do sum_k dSC_ik.U_ik
    if (what_force == Pulay .OR. what_force == HF_and_Pulay) then
       do k = 1, 3
          do spin = 1, nspin
             ! Note that matrix_diagonal accumulates HF_NL_force(k,:)
             call matrix_diagonal(matdSC(k), matU(spin), &
                                  HF_NL_force(k,:), SPrange, inode)
          end do ! spin
       end do ! k
    end if

    ! Evaluate the Hellmann-Feynman term - due to the chis changing
    if (what_force == HF .or. what_force == HF_and_Pulay) then
       do k = 1, 3
          do spin = 1, nspin
             ! Note that matrix_diagonal accumulates HF_NL_force(k,:)
             call matrix_diagonal(matdCS(k), matUT(spin), &
                                  HF_NL_force(k,:), PSrange,inode)
          end do ! spin
       end do ! k
    end if

    call gsum(HF_NL_force, 3, n_atoms)

    do k = 3, 1, -1
       call free_temp_matrix(matdCS(k))
       call free_temp_matrix(matdSC(k))
    end do
    
    return
  end subroutine get_HF_non_local_force
  !!***

  ! -----------------------------------------------------------
  ! Subroutine get_KE_force
  ! -----------------------------------------------------------
  
  !!****f* force_module/get_KE_force *
  !!
  !!  NAME 
  !!   get_KE_force
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Evaluates the force due to the change in the kinetic
  !!   energy matrix when an atom moves. This is therefore
  !!   the kinetic pulay type I force. As the onsite KE is evaluated
  !!   on the blip grid, there is _no_ contribution; the contribution
  !!   is due to the change in the intersite terms.
  !!
  !!   If we just have a single support function per atom...
  !! (the extension to NSF!=1 is standard...)
  !!   The gradient of the energy when atom i moves in direction \alpha
  !!   is given by a sum over atoms j, directions \beta and the grid
  !!
  !! (d/dR_{i\alpha}) KE = 2 \sum_j \sum_{\beta} \sum_{grid} 
  !!                         Grad_{\beta} psi_j  * 
  !!                       (d/dR_{i\alpha}) Grad_{\beta} psi_i  *
  !!                         K_{ij}   * grid_point_volume             [i!=j]
  !!
  !!   This can be written alternatively (more usefully) as
  !!
  !! (d/dR_{i\alpha}) KE = (d/dR_{i\alpha}) T_{ij} K_{ij}           [i!=j]
  !!
  !!   where
  !!
  !! (d/dR_{i\alpha}) T_{ij} = 2 \sum_{\beta} \sum_{grid}
  !!                             grid_point_volume * Grad_{\beta} psi_j  * 
  !!                           (d/dR_{i\alpha}) Grad_{\beta} psi_i
  !!
  !!   So within the loop over direction (for the force) we need a loop
  !!   over the components of the grad (\beta). For each of these we
  !!   evaluate Grad_{\beta} psi_j [blip_to_grad] and
  !! (d/dR_{i\alpha}) Grad_{\beta} psi_i [blip_to_gradgrad], and thus
  !! (d/dR_{i\alpha}) T_{ij} [get_matrix_elements].
  !!   We then loop through the list of overlap range interactions, and
  !!   accumulate the force due to that interaction onto the atom i.
  !!
  !!  INPUTS
  !! 
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   C.M.Goringe
  !!  CREATION DATE
  !!   03/03/97
  !!  MODIFICATION HISTORY
  !!   15/08/2000 TM
  !!    New get_matrix_elements
  !!   15/01/2001 TM 
  !!    New blip_to_grad
  !!   15/05/2001 dave
  !!    ROBODoc headers, new get_matrix_elements
  !!   17/05/2001 dave
  !!    Shortened calls to blip_to_grad and blip_to_gradgrad
  !!   21/05/2001 dave
  !!    Shortened overall subroutine call
  !!   11/06/2001 dave
  !!    Added RCS Id and Log tags and GenComms
  !!   12/06/2001 dave
  !!    Included in force_module
  !!   08:16, 2003/10/01 dave
  !!    Added structure for preparing for PAO basis set
  !!   2011/11/24 L.Tong
  !!    Added spin polarisation
  !!   2012/03/26 L.Tong
  !!   - Changed spin implementation
  !!  SOURCE
  !!
  subroutine get_KE_force(KE_force, n_atoms)

    use datatypes
    use numbers
    use primary_module,              only: bundle
    use matrix_module,               only: matrix, matrix_halo
    use matrix_data,                 only: mat, Hrange, halo
    use cover_module,                only: BCS_parts
    use mult_module,                 only: allocate_temp_matrix,      &
                                           free_temp_matrix,          &
                                           return_matrix_value, matK, &
                                           matrix_pos
    use GenBlas
    use set_bucket_module,           only: rem_bucket, sf_H_sf_rem
    use calc_matrix_elements_module, only: get_matrix_elements_new
    use blip_grid_transform_module,  only: blip_to_grad_new,          &
                                           blip_to_gradgrad_new
    use GenComms,                    only: my_barrier, gsum, inode,   &
                                           ionode
    use global_module,               only: iprint_MD, flag_basis_set, &
                                           blips, PAOs, sf,           &
                                           flag_onsite_blip_ana,      &
                                           nspin, spin_factor
    use build_PAO_matrices,          only: assemble_deriv_2
    use functions_on_grid,           only: H_on_supportfns,           &
                                           allocate_temp_fn_on_grid,  &
                                           free_temp_fn_on_grid

    implicit none

    ! Passed variables
    integer :: n_atoms
    real(double), dimension(3, n_atoms) :: KE_force
    ! local variables
    integer :: i, j, grad_direction, force_direction, element, np, nn,&
               atom, n1, n2, mat_grad_T, ist, gcspart, iprim, tmp_fn, &
               spin


!    ! First, clear the diagonal blocks of data K; this is the easiest way 
!    ! to avoid doing the onsite terms
    KE_force = zero
    mat_grad_T = allocate_temp_matrix(Hrange,0)
    ! Now, for the offsite part, done on the integration grid.
    if (flag_basis_set == blips) then
       
       tmp_fn = allocate_temp_fn_on_grid(sf)
       call start_timer(tmr_std_matrices)
       do grad_direction = 1, 3 

          ! get the Grad_{\beta} psi_j term        
          call blip_to_grad_new(inode-1, grad_direction, H_on_supportfns(1))
          do force_direction = 1, 3
             ! get the (d/dR_{i\alpha}) Grad_{\beta} psi_i term        
             call blip_to_gradgrad_new(inode-1, grad_direction, &
                                       force_direction, tmp_fn)
             ! now get the (d/dR_{i\alpha}) T_{ij} term from the above 
             !new matrix_elements
             call get_matrix_elements_new(inode-1,                 &
                                          rem_bucket(sf_H_sf_rem), &
                                          mat_grad_T, tmp_fn,      &
                                          H_on_supportfns(1))
             iprim = 0
             do np = 1,bundle%groups_on_node
                if (bundle%nm_nodgroup(np) > 0) then
                   do i = 1, bundle%nm_nodgroup(np)
                      ! The numbering of the ig_prim index is the same
                      ! as a sequential index running over atoms in
                      ! the primary set (seen in pulay force for
                      ! instance) DRB and TM 10:38, 29/08/2003
                      iprim = iprim+1
                      atom = bundle%ig_prim(bundle%nm_nodbeg(np)+i-1)
                      do j = 1,mat(np,Hrange)%n_nab(i)
                         ist = mat(np,Hrange)%i_acc(i)+j-1
                         gcspart =                                                &
                              BCS_parts%icover_ibeg(mat(np,Hrange)%i_part(ist)) + &
                              mat(np,Hrange)%i_seq(ist) - 1
                         ! matK(1) here is just to work out the matrix
                         ! position, it is going to be the same as
                         ! matK(nspin)
                         element =                       &
                              matrix_pos(matK(1), iprim, &
                                         halo(Hrange)%i_halo(gcspart), 1, 1)
                         if ((.not. flag_onsite_blip_ana) .or. &
                             (element /= mat(np,Hrange)%onsite(i))) then
                            do n1 = 1, mat(np,Hrange)%ndimj(ist)
                               do n2 = 1, mat(np,Hrange)%ndimi(i)
                                  do spin = 1, nspin
                                     KE_force(force_direction,atom) =       &
                                          KE_force(force_direction,atom) +  &
                                          spin_factor *                     &
                                          return_matrix_value(matK(spin),   &
                                                              np, i, iprim, &
                                                              j, n2, n1) *  &
                                          return_matrix_value(mat_grad_T,   &
                                                              np, i, iprim, &
                                                              j, n2, n1)
                                  end do ! spin
                               end do ! n2
                            end do ! n1
                         end if
                      end do ! j = mat%n_nab
                   end do ! i = bundle%nm_nodgroup
                end if  ! (bundle%nm_nodgroup(np) > 0)
             end do ! np = bundle%groups_on_node
          end do ! force directions
       end do ! grad directions
       call stop_timer(tmr_std_matrices)
       call free_temp_fn_on_grid(tmp_fn)

    else if (flag_basis_set==PAOs) then

       do force_direction = 1, 3
          ! Build derivatives
          call assemble_deriv_2(force_direction,Hrange, mat_grad_T, 2)
          call start_timer(tmr_std_matrices)
          iprim = 0
          do np = 1, bundle%groups_on_node
             if (bundle%nm_nodgroup(np) > 0) then
                do i = 1, bundle%nm_nodgroup(np)
                   ! The numbering of the ig_prim index is the same as
                   ! a sequential index running over atoms in the
                   ! primary set (seen in pulay force for instance)
                   ! DRB and TM 10:38, 29/08/2003
                   atom = bundle%ig_prim(bundle%nm_nodbeg(np)+i-1)
                   iprim = iprim + 1
                   do j = 1, mat(np,Hrange)%n_nab(i)
                      ist = mat(np,Hrange)%i_acc(i) + j - 1
                      gcspart =                                                &
                           BCS_parts%icover_ibeg(mat(np,Hrange)%i_part(ist)) + &
                           mat(np,Hrange)%i_seq(ist) - 1
                      ! matK(1) is used to just to get the position
                      element =                    &
                           matrix_pos(matK(1), iprim, &
                                      halo(Hrange)%i_halo(gcspart), 1, 1)
                      if (element /= mat(np,Hrange)%onsite(i)) then
                         do n1 = 1, mat(np,Hrange)%ndimj(ist)
                            do n2 = 1, mat(np,Hrange)%ndimi(i)
                               do spin = 1, nspin
                                  KE_force(force_direction,atom) =       &
                                       KE_force(force_direction,atom) +  &
                                       spin_factor *                     &
                                       return_matrix_value(matK(spin),   &
                                                           np, i, iprim, &
                                                           j, n2, n1) *  &
                                       return_matrix_value(mat_grad_T,   &
                                                           np, i, iprim, &
                                                           j, n2, n1)
                               end do ! spin
                            end do ! n2
                         end do ! n1
                      end if ! (element /= mat(np,Hrange)%onsite(i))
                   end do ! j
                end do ! i
             end if  ! (bundle%nm_nodgroup(np) > 0)
          end do ! np
          call stop_timer(tmr_std_matrices)
       end do ! force directions
    end if ! (flag_basis_set == blips)
    
    call gsum(KE_force, 3, n_atoms)

    call free_temp_matrix(mat_grad_T)

    return
  end subroutine get_KE_force
  !!***


! -----------------------------------------------------------
! Subroutine matrix_diagonal
! -----------------------------------------------------------

!!****f* force_module/matrix_diagonal *
!!
!!  NAME 
!!   matrix_diagonal
!!  USAGE
!! 
!!  PURPOSE
!!   Basically, this is designed for the non-local contribution to the 
!!   forces, and does sum_k one_ik.two^T_ki as sum_k one_ik two_ik
!!   We're being _very_ bad, and assuming that i_elements is sorted on 
!!   atom on node, so that the first n entries are for atom one on this
!!   node, etc.
!! 
!!   Now (a) complies with new matrix mults and (b) is used by lots of
!!   the force routines
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   7/7/98 (Happy 5 months Rob !)
!!  MODIFICATION HISTORY
!!   6/6/00 dave
!!    Changed to use new matrix mults
!!   21/06/2001 dave
!!    Added ROBODoc header and included in force_module
!!  SOURCE
!!
  subroutine matrix_diagonal(matA, matB, diagonal, range, inode)

    use datatypes
    use primary_module, only : bundle
    use matrix_module, only: matrix, matrix_halo
    use matrix_data, only : mat, halo
    use cover_module, only: BCS_parts
    use mult_module, only: return_matrix_value_pos, matrix_pos
    use GenBlas

    implicit none

    ! Shared variables
    real(double) :: diagonal( :)

    integer :: range, inode,matA,matB

    ! Local variables
    integer :: iprim, np, i, j, atom,element, n1,n2, ist, gcspart

    iprim = 0
    call start_timer(tmr_std_matrices)
    do np = 1,bundle%groups_on_node
       if(bundle%nm_nodgroup(np) > 0) then
          do i=1,bundle%nm_nodgroup(np)
             iprim = iprim + 1
             atom = bundle%ig_prim(iprim)
             do j = 1,mat(np,range)%n_nab(i)
                ist = mat(np,range)%i_acc(i)+j-1
                gcspart = BCS_parts%icover_ibeg(mat(np,range)%i_part(ist))+mat(np,range)%i_seq(ist)-1
                do n2 = 1,mat(np,range)%ndimj(ist)
                   do n1 = 1,mat(np,range)%ndimi(i)
                      element = matrix_pos(matA,iprim,halo(range)%i_halo(gcspart),n1,n2)
                      diagonal(atom) = diagonal(atom) + &
                           return_matrix_value_pos(matA,element)*return_matrix_value_pos(matB,element)
                   end do
                end do
             end do
          end do
       end if  !  (bundle%nm_nodgroup(np) > 0)
    end do
    call stop_timer(tmr_std_matrices)
    return
  end subroutine matrix_diagonal
!!***

  ! -----------------------------------------------------------
  ! Subroutine get_nonSC_correction_force
  ! -----------------------------------------------------------
  
  !!****f* force_module/get_nonSC_correction_force_nospin *
  !!
  !!  NAME 
  !!   get_nonSC_correction_force_nospin
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Gets the correction to the forces for when we're doing
  !!   Harris-Foulkes (i.e. non self-consistent ab initio tight binding)
  !!   calculations.  Operates in exactly the same manner as the
  !!   Hellmann-Feynman forces for the local part of the pseudopotential
  !!  INPUTS
  !! 
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   D.R.Bowler
  !!  CREATION DATE
  !!   16:12, 20/03/2003 drb 
  !!  MODIFICATION HISTORY
  !!   11:53, 30/09/2003 drb 
  !!    Removed get_electronic_density (done above in force) and
  !!    simplified subroutine call
  !!   2004/10/05 drb
  !!    Added hartree_module use
  !!   14:08, 2006/07/17
  !!    Added functional type selector and PBE force
  !!   2008/11/13
  !!    Added new PBE functional types (revPBE, RPBE)
  !!   2011/03/31 M.Arita
  !!    Added the contribution from P.C.C.
  !!   2011/10/17 L.Tong
  !!    - Added spin polarisation
  !!    - Added optional parameter density_out_dn. The density_out array will
  !!      be used to store the total out density, where as a new local
  !!      arrays density_out_up is used to store the spin up component
  !!      of the out put density. BUT, IMPORTANT, upon input, the
  !!      density_out is used for the spin up component of the output
  !!      density, we copy this into density_out_up immediately inside
  !!      the routine and density_out is then used as total output. And
  !!      at the end of the array density_out is reverted back to the
  !!      values stored in density_out_up and density_out_up is
  !!      destroyed.
  !!    - Removed dependence on maxngrid, and moved all dependence on
  !!      the grid size to the input parameter size
  !!    - made potential to be taken from potential_module directly
  !!      instead of as an input parameter
  !!   2012/02/12 L.Tong
  !!    - Changed procedure name to get_nonSC_correction_force_nospin.
  !!      This subroutine is to be called from the interface
  !!      get_nonSC_correction_force_nospin.
  !!    - Removed all spin polarised calculations, this subroutine is to
  !!      be used for spin non-polarised calculations only.
  !!   2012/02/13 L.Tong
  !!    - Made h_potential automatic array.
  !!   2012/03/26 L.Tong
  !!    - Changed spin implementation.
  !!    - merged subroutines get_nonSC_correction_force_nospin and
  !!      get_nonSC_correction_force_spin
  !!    - renamed subroutine name back to get_nonSC_correction_force
  !!    - deleted the interface get_nonSC_correction_force
  !!  SOURCE
  !!
  subroutine get_nonSC_correction_force(hf_force, density_out, inode, &
                                        ionode, n_atoms, size)
    
    use datatypes
    use numbers
    use species_module,      only: species
    use GenComms,            only: gsum
    use global_module,       only: rcellx, rcelly, rcellz, id_glob,    &
                                   ni_in_cell, species_glob, dens,     &
                                   flag_functional_type,               &
                                   functional_lda_pz81,                &
                                   functional_lda_gth96,               &
                                   functional_lda_pw92,                &
                                   functional_gga_pbe96,               &
                                   functional_gga_pbe96_rev98,         &
                                   functional_gga_pbe96_r99,           &
                                   functional_lsda_pw92,               &
                                   area_moveatoms, IPRINT_TIME_THRES3, &
                                   flag_pcc_global, nspin, spin_factor
    use block_module,        only: nx_in_block, ny_in_block,           &
                                   nz_in_block, n_pts_in_block
    use group_module,        only: blocks, parts
    use primary_module,      only: domain
    use cover_module,        only: DCS_parts
    use set_blipgrid_module, only: naba_atm
    use GenComms,            only: my_barrier, cq_abort
    use atomic_density,      only: atomic_density_table
    use pseudo_tm_info,      only: pseudo
    use spline_module,       only: dsplint
    use dimens,              only: grid_point_volume, n_my_grid_points
    use GenBlas,             only: axpy
    use density_module,      only: density, density_scale, density_pcc
    use hartree_module,      only: hartree
    use potential_module,    only: potential
    use memory_module,       only: reg_alloc_mem, reg_dealloc_mem,     &
                                   type_dbl
    use timer_module,        only: cq_timer, start_timer, stop_timer,  &
                                   print_timer, stop_print_timer,      &
                                   WITH_LEVEL, TIME_ACCUMULATE_NO,     &
                                   TIME_ACCUMULATE_YES

    implicit none

    ! Passed variables
    integer :: n_atoms, size
    integer :: inode, ionode
    real(double), dimension(:,:) :: density_out
    real(double), dimension(:,:) :: hf_force

    ! Local variables
    integer        :: i, j, my_block, n, the_species, iatom, spin, spin_2
    integer        :: ix, iy, iz, iblock, ipoint, igrid, stat
    integer        :: ipart, jpart, ind_part, ia, ii, icover, ig_atom
    real(double)   :: derivative, h_energy, rx, ry, rz, r2, r_from_i,  &
                      x, y, z, step
    real(double)   :: dcellx_block, dcelly_block, dcellz_block
    real(double)   :: dcellx_grid, dcelly_grid, dcellz_grid
    real(double)   :: xatom, yatom, zatom
    real(double)   :: xblock, yblock, zblock
    real(double)   :: dx, dy, dz, loc_cutoff, loc_cutoff2, v
    real(double)   :: pcc_cutoff, pcc_cutoff2, step_pcc, x_pcc, y_pcc, &
                      z_pcc, derivative_pcc, v_pcc
    logical        :: range_flag
    type(cq_timer) :: tmr_l_tmp1, tmr_l_tmp2

    real(double), dimension(size)             :: h_potential,          &
                                                 density_total,        &
                                                 density_out_total
    real(double), dimension(nspin)            :: pot_here, fx_1, fy_1, &
                                                 fz_1, fx_pcc, fy_pcc, &
                                                 fz_pcc, pot_here_pcc
    real(double), dimension(size,nspin,nspin) :: dVxc_drho

                                 
    ! only for GGA with P.C.C. 
    real(double), allocatable, dimension(:)   :: h_potential_in,       &
                                                 wk_grid_total,        &
                                                 density_out_GGA_total
    real(double), allocatable, dimension(:,:) :: wk_grid,              &
                                                 density_out_GGA
    
    HF_force = zero
    
    dcellx_block = rcellx / blocks%ngcellx
    dcelly_block = rcelly / blocks%ngcelly
    dcellz_block = rcellz / blocks%ngcellz

    dcellx_grid = dcellx_block / nx_in_block
    dcelly_grid = dcelly_block / ny_in_block
    dcellz_grid = dcellz_block / nz_in_block
    
    ! We need a potential-like array containing the appropriate
    ! differences (between VHa for input and output charge densities
    ! and between Vxc' for input and output densities) Something like
    ! this:
    
    ! First the PAD n(r), density
    call start_timer(tmr_l_tmp2) 

    h_potential = zero
    potential = zero
    density_total = spin_factor * sum(density, 2)
    density_out_total = spin_factor * sum(density_out, 2)

    call hartree(density_total, h_potential, size, h_energy)

    do spin = 1, nspin
       call axpy(size, one, h_potential, 1, potential(:,spin), 1)
    end do

    call stop_timer(tmr_l_tmp2, TIME_ACCUMULATE_NO)
    
    ! for P.C.C.
    if (flag_pcc_global) then
       allocate(wk_grid_total(size), wk_grid(size,nspin), STAT=stat)
       if (stat /= 0) &
            call cq_abort('Error allocating wk_grids in &
                           &get_nonSC_correction ', stat)
       call reg_alloc_mem(area_moveatoms, (nspin + 1) * size, type_dbl)
       do spin = 1, nspin
          wk_grid(:,spin) = density(:,spin) + half * density_pcc(:)
       end do
       wk_grid_total = spin_factor * sum(wk_grid, 2)
       ! only for GGA
       if ((flag_functional_type == functional_gga_pbe96) .or. &
           (flag_functional_type == functional_gga_pbe96_rev98) .or. &
           (flag_functional_type == functional_gga_pbe96_r99)) then
          allocate(density_out_GGA_total(size), density_out_GGA(size,nspin), &
                   STAT=stat)
          if (stat /= 0)&
               call cq_abort ('Error allocating &
                               &density_out_GGAs in get_nonSC_force ', stat)
          call reg_alloc_mem(area_moveatoms, (nspin + 1) * size, type_dbl)
          do spin = 1, nspin
             density_out_GGA(:,spin) = density_out(:,spin) + &
                                       half * density_pcc(:)
          end do          
          density_out_GGA_total = spin_factor * sum(density_out_GGA, 2)
          ! copy hartree potential
          allocate(h_potential_in(size), STAT=stat)
          if (stat /= 0) &
               call cq_abort('Error allocating h_potential_in in &
                              &get_nonSC_force ', stat)
          call reg_alloc_mem(area_moveatoms, size, type_dbl)
          h_potential_in = h_potential
       end if
    end if
    
    call start_timer (tmr_l_tmp1, WITH_LEVEL)
    
    if (nspin == 1) then

       select case (flag_functional_type)
       case (functional_lda_pz81)
          if (flag_pcc_global) then
             call get_dxc_potential(wk_grid_total, dVxc_drho(:,1,1), size)
          else
             call get_dxc_potential(density_total, dVxc_drho(:,1,1), size)
          end if
       case (functional_lda_gth96)
          if (flag_pcc_global) then
             call get_GTH_dxc_potential(wk_grid_total, dVxc_drho(:,1,1), size)
          else
             call get_GTH_dxc_potential(density_total, dVxc_drho(:,1,1), size)
          end if
       case (functional_lda_pw92)
          if (flag_pcc_global) then
             call get_dxc_potential_LDA_PW92(wk_grid_total,        &
                                             dVxc_drho(:,1,1), size)
          else
             call get_dxc_potential_LDA_PW92(density_total,        &
                                             dVxc_drho(:,1,1), size)
          end if
       case (functional_gga_pbe96) ! Original PBE
          if (flag_pcc_global) then
             call get_dxc_potential_GGA_PBE(wk_grid_total,         &
                                            density_out_GGA_total, &
                                            potential(:,1), size)
          else
             call get_dxc_potential_GGA_PBE(density_total,         &
                                            density_out_total,     &
                                            potential(:,1), size)
          end if
       case (functional_gga_pbe96_rev98)
          ! PBE with kappa of PRL 80, 890 (1998)
          if (flag_pcc_global) then
             call get_dxc_potential_GGA_PBE(wk_grid_total,         &
                                            density_out_total,     &
                                            potential(:,1), size,  &
                                            functional_gga_pbe96_rev98)
          else
             call get_dxc_potential_GGA_PBE(density_total,         &
                                            density_out_total,     &
                                            potential(:,1), size,  &
                                            functional_gga_pbe96_rev98)
          end if
       case (functional_gga_pbe96_r99)
          ! PBE with form of PRB 59, 7413 (1999)
          if (flag_pcc_global) then
             call get_dxc_potential_GGA_PBE(wk_grid_total,         &
                                            density_out_total,     &
                                            potential(:,1), size,  &
                                            functional_gga_pbe96_r99)
          else
             call get_dxc_potential_GGA_PBE(density_total,         &
                                            density_out_total,     &
                                            potential(:,1), size,  &
                                            functional_gga_pbe96_r99)
          end if
       case default
          if (flag_pcc_global) then
             call get_dxc_potential(wk_grid_total, dVxc_drho(:,1,1), size)
          else
             call get_dxc_potential(density_total, dVxc_drho(:,1,1), size)
          end if
       end select

    else ! if doing spin polarised calculations

       select case (flag_functional_type)
       case (functional_lsda_pw92)
          ! LSDA with spin polarisation, PW92 call
          if (flag_pcc_global) then
             call get_dxc_potential_LSDA_PW92(wk_grid, dVxc_drho, size)
          else
             call get_dxc_potential_LSDA_PW92(density, dVxc_drho, size)
          end if
       case default
          if (flag_pcc_global) then
             call get_dxc_potential_LSDA_PW92(wk_grid, dVxc_drho, size)
          else
             call get_dxc_potential_LSDA_PW92(density, dVxc_drho, size)
          end if
       end select
       
    end if ! (nspin == 1)
    
    ! deallocating density_out_GGA: only for P.C.C.
    if (flag_pcc_global)  then
       if ((flag_functional_type == functional_gga_pbe96) .or.       &
           (flag_functional_type == functional_gga_pbe96_rev98) .or. &
           (flag_functional_type == functional_gga_pbe96_r99)) then
          deallocate(density_out_GGA_total, density_out_GGA,         &
                     STAT=stat)
          if (stat /= 0) &
               call cq_abort('Error deallocating density_out_GGAs in &
                              &get_nonSC_force ', stat)
          call reg_dealloc_mem(area_moveatoms, (nspin + 1) * size, type_dbl)
       end if
    end if !flag_pcc_global

    ! for GGA
    if (flag_pcc_global .and.                                      &
        ((flag_functional_type == functional_gga_pbe96) .or.       &
         (flag_functional_type == functional_gga_pbe96_rev98) .or. &
         (flag_functional_type == functional_gga_pbe96_r99))) then 
       ! make a copy of potential at this point
       ! use wk_grid as a temporary storage
       do spin = 1, nspin
          wk_grid(:,spin) = potential(:,spin)
       end do
       ! wk_grid = zero
       ! do spin = 1, nspin
       !    call axpy(size, one, potential(:,spin), 1, wk_grid(:,spin), 1)
       ! end do
    end if
    
    ! for LDA
    if ((flag_functional_type /= functional_gga_pbe96) .and.       &
        (flag_functional_type /= functional_gga_pbe96_rev98) .and. &
        (flag_functional_type /= functional_gga_pbe96_r99)) then
       do spin = 1, nspin
          do spin_2 = 1, nspin
             do i = 1, n_my_grid_points
                ! contribution from (n^PAD - n^out) * mu'(n^PAD)
                potential(i,spin) =                                &
                     potential(i,spin) + spin_factor *             &
                     (density(i,spin_2) - density_out(i,spin_2)) * &
                     dVxc_drho(i,spin_2,spin)
             end do ! i
          end do ! spin_2
       end do ! spin
    end if ! for LDA
    
    call stop_print_timer(tmr_l_tmp1, "NSC force - XC", IPRINT_TIME_THRES3)
    
    ! Restart of the timer; level assigned here
    call start_timer(tmr_l_tmp2, WITH_LEVEL)
    h_potential = zero  
    call hartree(density_out_total, h_potential, size, h_energy)
    do spin = 1, nspin
       call axpy(size, -one, h_potential, 1, potential(:,spin), 1)
    end do
    ! now, potential = - delta V_H - ( n_out - n_PAD ) * dxc_potential
    call stop_print_timer(tmr_l_tmp2, "NSC force - Hartree", &
                          IPRINT_TIME_THRES3, TIME_ACCUMULATE_YES)
    call my_barrier()
    call start_timer(tmr_l_tmp1, WITH_LEVEL) 
    do iblock = 1, domain%groups_on_node ! primary set of blocks
       xblock = (domain%idisp_primx(iblock) + domain%nx_origin - 1) * dcellx_block
       yblock = (domain%idisp_primy(iblock) + domain%ny_origin - 1) * dcelly_block
       zblock = (domain%idisp_primz(iblock) + domain%nz_origin - 1) * dcellz_block
       if (naba_atm(dens)%no_of_part(iblock) > 0) then ! if there are naba atoms
          iatom = 0
          do ipart = 1, naba_atm(dens)%no_of_part(iblock)
             jpart = naba_atm(dens)%list_part(ipart,iblock)
             if (jpart > DCS_parts%mx_gcover)&
                  call cq_abort('set_ps: JPART ERROR ', ipart, jpart)
             ind_part = DCS_parts%lab_cell(jpart)
             do ia = 1, naba_atm(dens)%no_atom_on_part(ipart, iblock)
                iatom = iatom + 1
                ii = naba_atm(dens)%list_atom(iatom, iblock)
                icover = DCS_parts%icover_ibeg(jpart) + ii - 1
                ig_atom = id_glob(parts%icell_beg(ind_part) + ii - 1)
                if (parts%icell_beg(ind_part) + ii - 1 > ni_in_cell) &
                     call cq_abort('set_ps: globID ERROR ', &
                                   ii, parts%icell_beg(ind_part))
                if (icover > DCS_parts%mx_mcover) &
                     call cq_abort ('set_ps: icover ERROR ', &
                                    icover, DCS_parts%mx_mcover)
                xatom = DCS_parts%xcover(icover)
                yatom = DCS_parts%ycover(icover)
                zatom = DCS_parts%zcover(icover)
                the_species = species_glob(ig_atom)
                !the_species=species(ig_atom)
                loc_cutoff = atomic_density_table(the_species)%cutoff
                loc_cutoff2 = loc_cutoff*loc_cutoff
                step = loc_cutoff / &
                       real(atomic_density_table(the_species)%length - 1, double)
                ipoint = 0
                do iz = 1, nz_in_block
                   do iy = 1, ny_in_block
                      do ix = 1, nx_in_block
                         ipoint = ipoint + 1
                         igrid = n_pts_in_block * (iblock - 1) + ipoint
                         if (igrid > n_my_grid_points) &
                              call cq_abort('get_nonSC_force: igrid error ',&
                                            igrid,n_my_grid_points)
                         ! scale with integration measure
                         do spin = 1, nspin
                            pot_here(spin) = &
                                 potential(igrid,spin) * grid_point_volume
                         end do
                         dx = dcellx_grid * (ix - 1)
                         dy = dcelly_grid * (iy - 1)
                         dz = dcellz_grid * (iz - 1)
                         rx = xblock + dx - xatom
                         ry = yblock + dy - yatom
                         rz = zblock + dz - zatom
                         r2 = rx * rx + ry * ry + rz * rz
                         if (r2 < loc_cutoff2) then
                            r_from_i = sqrt(r2)
                            if (r_from_i > very_small) then
                               x = rx / r_from_i
                               y = ry / r_from_i
                               z = rz / r_from_i
                            else
                               x = zero
                               y = zero
                               z = zero
                            end if
                            call dsplint(                                       &
                                 step,                                          &
                                 atomic_density_table(the_species)%table(:),    &
                                 atomic_density_table(the_species)%d2_table(:), &
                                 atomic_density_table(the_species)%length,      &
                                 r_from_i, v, derivative, range_flag)
                            if (range_flag) &
                                 call cq_abort('get_nonSC_force: overrun problem')
                            ! the factor of half here is because spin
                            ! up or dn densities were constructed as
                            ! half of the sum of atomic densities
                            derivative = half * derivative
                            do spin = 1, nspin
                               fx_1(spin) = -x * derivative * density_scale(spin)
                               fy_1(spin) = -y * derivative * density_scale(spin)
                               fz_1(spin) = -z * derivative * density_scale(spin)
                            end do
                         else
                            do spin = 1, nspin
                               fx_1(spin) = zero
                               fy_1(spin) = zero
                               fz_1(spin) = zero
                            end do
                         end if
                         ! could be written in a simpler form, but
                         ! written this way gives more clear idea
                         ! on what we are doing here.
                         do spin = 1, nspin
                            HF_force(1,ig_atom) =      &
                                 HF_force(1,ig_atom) + &
                                 spin_factor * fx_1(spin) * pot_here(spin)
                            HF_force(2,ig_atom) =      &
                                 HF_force(2,ig_atom) + &
                                 spin_factor * fy_1(spin) * pot_here(spin)
                            HF_force(3,ig_atom) =      &
                                 HF_force(3,ig_atom) + &
                                 spin_factor * fz_1(spin) * pot_here(spin)
                         end do ! spin
                      end do !ix
                   end do  !iy
                end do   !iz
             end do ! naba_atoms
          end do ! naba_part
       end if !(naba_atm(dens)%no_of_part(iblock) > 0) !naba atoms?
    end do ! iblock : primary set of blocks
    
    call stop_print_timer(tmr_l_tmp1, "NSC force - Orbital part", &
                          IPRINT_TIME_THRES3)
    
    ! only called for P.C.C.
    ! compute - int d^3r ( delta n_{v} * dxc(n_{c} + n_{v} ) * dn_{c} )
    if (flag_pcc_global) then
       if ((flag_functional_type /= functional_gga_pbe96) .and.       &
           (flag_functional_type /= functional_gga_pbe96_rev98) .and. &
           (flag_functional_type /= functional_gga_pbe96_r99)) then
          ! For LDA
          potential = zero
          do spin = 1, nspin
             do spin_2 = 1, nspin
                do i = 1, n_my_grid_points
                   potential(i,spin) =                                &
                        potential(i,spin) +                           &
                        spin_factor *                                 &
                        (density(i,spin_2) - density_out(i,spin_2)) * &
                        dVxc_drho(i,spin_2,spin)
                end do
             end do          
          end do
       else if ((flag_functional_type == functional_gga_pbe96) .or.       &
                (flag_functional_type == functional_gga_pbe96_rev98) .or. &
                (flag_functional_type == functional_gga_pbe96_r99) ) then
          ! for GGA
          potential = zero
          do spin = 1, nspin
             do i = 1, n_my_grid_points
                ! -delta n * dxc_potential
                potential(i,spin) = wk_grid(i,spin) - h_potential_in(i)
             end do
          end do
       end if
       
       call start_timer(tmr_l_tmp1, WITH_LEVEL)
       do iblock = 1, domain%groups_on_node ! primary set of blocks
          xblock = (domain%idisp_primx(iblock) + domain%nx_origin - 1) * &
                   dcellx_block
          yblock = (domain%idisp_primy(iblock) + domain%ny_origin - 1) * &
                   dcelly_block
          zblock = (domain%idisp_primz(iblock) + domain%nz_origin - 1) * &
                   dcellz_block
          if (naba_atm(dens)%no_of_part(iblock) > 0) then ! if there are naba atoms
             iatom = 0
             do ipart = 1, naba_atm(dens)%no_of_part(iblock)
                jpart = naba_atm(dens)%list_part(ipart, iblock)
                if (jpart > DCS_parts%mx_gcover) &
                     call cq_abort('set_ps: JPART ERROR ', ipart, jpart)
                ind_part = DCS_parts%lab_cell(jpart) 
                do ia = 1, naba_atm(dens)%no_atom_on_part(ipart, iblock)
                   iatom = iatom + 1
                   ii = naba_atm(dens)%list_atom(iatom, iblock)
                   icover = DCS_parts%icover_ibeg(jpart) + ii - 1
                   ig_atom = id_glob(parts%icell_beg(ind_part) + ii - 1)
                   the_species = species_glob(ig_atom)
                   ! for P.C.C. treatment
                   if (.not. pseudo(the_species)%flag_pcc) cycle
                   if (parts%icell_beg(ind_part) + ii - 1 > ni_in_cell) &
                        call cq_abort('set_ps: globID ERROR ', &
                                      ii, parts%icell_beg(ind_part))
                   if (icover > DCS_parts%mx_mcover) &
                        call cq_abort('set_ps: icover ERROR ', &
                                      icover, DCS_parts%mx_mcover)
                   xatom = DCS_parts%xcover(icover)
                   yatom = DCS_parts%ycover(icover)
                   zatom = DCS_parts%zcover(icover)
                   pcc_cutoff = pseudo(the_species)%chpcc%cutoff
                   pcc_cutoff2 = pcc_cutoff * pcc_cutoff
                   step_pcc = pseudo(the_species)%chpcc%delta
                   ipoint = 0
                   do iz = 1, nz_in_block
                      do iy = 1, ny_in_block
                         do ix = 1, nx_in_block
                            ipoint = ipoint+1
                            igrid = n_pts_in_block * (iblock - 1) + ipoint
                            if (igrid > n_my_grid_points) &
                                 call cq_abort('get_nonSC_force: igrid error ',&
                                               igrid, n_my_grid_points)
                            do spin = 1, nspin
                               pot_here_pcc(spin) = &
                                    potential(igrid,spin) * grid_point_volume
                            end do
                            dx = dcellx_grid * (ix - 1)
                            dy = dcelly_grid * (iy - 1)
                            dz = dcellz_grid * (iz - 1)
                            rx = xblock + dx - xatom
                            ry = yblock + dy - yatom
                            rz = zblock + dz - zatom
                            r2 = rx * rx + ry * ry + rz * rz
                            if (r2 < pcc_cutoff2) then
                               r_from_i = sqrt( r2 )
                               if ( r_from_i > very_small ) then
                                  x_pcc = rx / r_from_i
                                  y_pcc = ry / r_from_i
                                  z_pcc = rz / r_from_i
                               else
                                  x_pcc = zero
                                  y_pcc = zero
                                  z_pcc = zero
                               end if
                               call dsplint(step_pcc, &
                                            pseudo(the_species)%chpcc%f(:), &
                                            pseudo(the_species)%chpcc%d2(:), &
                                            pseudo(the_species)%chpcc%n, &
                                            r_from_i, v_pcc, derivative_pcc, &
                                            range_flag)
                               if (range_flag) &
                                    call cq_abort('get_nonSC_force: &
                                                  &overrun problem')
                               ! there is a factor of half for
                               ! derivative_pcc, because I assume the
                               ! contribution from the pcc density
                               ! correction to each spin channel is
                               ! half of the total.
                               derivative_pcc = half * derivative_pcc
                               do spin = 1, nspin
                                  fx_pcc(spin) = -x_pcc * derivative_pcc * &
                                                 density_scale(spin)
                                  fy_pcc(spin) = -y_pcc * derivative_pcc * &
                                                 density_scale(spin)
                                  fz_pcc(spin) = -z_pcc * derivative_pcc * &
                                                 density_scale(spin)
                               end do
                            else
                               do spin = 1, nspin
                                  fx_pcc(spin) = zero
                                  fy_pcc(spin) = zero
                                  fz_pcc(spin) = zero
                               end do
                            end if
                            ! assuming derivative of ppc charge
                            ! (assumed same for different spin
                            ! components)
                            do spin = 1, nspin
                               HF_force(1,ig_atom) = &
                                    HF_force(1,ig_atom) + &
                                    spin_factor * &
                                    fx_pcc(spin) * pot_here_pcc(spin)
                               HF_force(2,ig_atom) = &
                                    HF_force(2,ig_atom) + &
                                    spin_factor * &
                                    fy_pcc(spin) * pot_here_pcc(spin)
                               HF_force(3,ig_atom) = &
                                    HF_force(3,ig_atom) + &
                                    spin_factor * &
                                    fz_pcc(spin) * pot_here_pcc(spin)
                            end do ! spin
                         end do !ix
                      end do  !iy
                   end do   !iz
                end do ! naba_atoms
             end do ! naba_part
          end if !(naba_atm(dens)%no_of_part(iblock) > 0) !naba atoms?
       end do ! iblock : primary set of blocks
    end if ! (flag_pcc_global)

    call start_timer(tmr_l_tmp1, WITH_LEVEL)
    call gsum(HF_force, 3, n_atoms)
    call stop_print_timer(tmr_l_tmp1, "NSC force - Compilation", &
                          IPRINT_TIME_THRES3)

    ! deallocating temporary arrays
    call start_timer(tmr_std_allocation)
    if (flag_pcc_global) then
       deallocate(wk_grid_total, wk_grid, STAT=stat)
       if (stat /= 0) &
            call cq_abort('Error deallocating wk_grid in &
                           &get_nonSC_correction_force ', stat)
       call reg_dealloc_mem(area_moveatoms, (nspin + 1) * size, type_dbl)
       if ((flag_functional_type == functional_gga_pbe96) .or. &
           (flag_functional_type == functional_gga_pbe96_rev98) .or. &
           (flag_functional_type == functional_gga_pbe96_r99)) then
          deallocate(h_potential_in, STAT=stat)
          if (stat /= 0) &
               call cq_abort('Error deallocating h_potential_in in &
                             &get_nonSC_correction_force ', stat)
          call reg_dealloc_mem(area_moveatoms, size, type_dbl)
       end if ! for GGA
    end if ! flag_pcc_global
    call stop_timer(tmr_std_allocation)
   
    return
  end subroutine get_nonSC_correction_force
  !!***
 

  ! -----------------------------------------------------------
  ! Subroutine get_pcc_force
  ! -----------------------------------------------------------
  
  !!****f* force_module/get_pcc_force *
  !!
  !!  NAME 
  !!   get_pcc_force
  !!  USAGE
  !! 
  !!  PURPOSE
  !!   Gets the P.C.C. force in the case where the partial core
  !!   correction is taken into account.  This contribution works on
  !!   both SCF/NSC calculations.
  !!  INPUTS
  !! 
  !! 
  !!  USES
  !! 
  !!  AUTHOR
  !!   M.Arita
  !!  CREATION DATE
  !!   12:03, 2011/03/31 M.Arita
  !!  MODIFICATION HISTORY
  !!   2011/10/12 L.Tong
  !!     Corrected memory allocation and deallocation registers
  !!     Added spin polarisation
  !!     - Assumed the pcc correction to density is the same for both
  !!       spin components, and hence the pcc correction will be half *
  !!       density_pcc for all spin
  !!     - xc_potential for spin polarised case is used to store the
  !!       total exchange-correlation potential. First the spin up
  !!       component is stored in xc_potential, then xc_potential =
  !!       xc_potential + xc_potential_dn
  !!   2012/03/25 L.Tong
  !!   - Changed spin implementation
  !!  SOURCE
  !!
  subroutine get_pcc_force(pcc_force, inode, ionode, n_atoms, size)

    use datatypes
    use numbers
    use species_module,      only: species
    use GenComms,            only: gsum
    use global_module,       only: rcellx, rcelly, rcellz, id_glob,    &
                                   ni_in_cell, species_glob, dens,     &
                                   flag_functional_type,               &
                                   functional_lda_pz81,                &
                                   functional_lda_gth96,               &
                                   functional_lda_pw92,                &
                                   functional_gga_pbe96,               &
                                   functional_gga_pbe96_rev98,         &
                                   functional_gga_pbe96_r99,           &
                                   area_moveatoms, IPRINT_TIME_THRES3, &
                                   nspin, spin_factor,                 &
                                   functional_lsda_pw92
    use block_module,        only: nx_in_block,ny_in_block,            &
                                   nz_in_block, n_pts_in_block
    use group_module,        only: blocks, parts
    use primary_module,      only: domain
    use cover_module,        only: DCS_parts
    use set_blipgrid_module, only: naba_atm
    use GenComms,            only: my_barrier, cq_abort
    use pseudo_tm_info,      only: pseudo
    use spline_module,       only: dsplint
    use dimens,              only: grid_point_volume, n_my_grid_points
    use GenBlas,             only: axpy
    use density_module,      only: density, density_scale, density_pcc
    use H_matrix_module,     only: get_xc_potential,                   &
                                   get_GTH_xc_potential,               &
                                   get_xc_potential_LDA_PW92,          &
                                   get_xc_potential_GGA_PBE,           &
                                   get_xc_potential_LSDA_PW92
    use maxima_module,       only: maxngrid
    use memory_module,       only: reg_alloc_mem, reg_dealloc_mem,     &
                                   type_dbl
    use timer_module,        only: cq_timer, start_timer, stop_timer,  &
                                   print_timer, stop_print_timer,      &
                                   WITH_LEVEL, TIME_ACCUMULATE_NO,     &
                                   TIME_ACCUMULATE_YES

    implicit none

    ! Passed variables
    integer :: n_atoms, size
    integer :: inode, ionode
    real(double), dimension(3,n_atoms) :: pcc_force

    ! Local variables
    integer        :: i, j, my_block, n, the_species, iatom, spin
    integer        :: ix, iy, iz, iblock, ipoint, igrid, stat
    integer        :: ipart, jpart, ind_part, ia, ii, icover, ig_atom
    real(double)   :: derivative_pcc, xc_energy, rx, ry, rz, r2,      &
                      r_from_i, x_pcc, y_pcc, z_pcc, step_pcc
    real(double)   :: dcellx_block, dcelly_block, dcellz_block
    real(double)   :: dcellx_grid, dcelly_grid, dcellz_grid
    real(double)   :: xatom, yatom, zatom, fx_pcc, fy_pcc, fz_pcc
    real(double)   :: xblock, yblock, zblock
    real(double)   :: dx, dy, dz, pcc_cutoff, pcc_cutoff2, electrons, &
                      v_pcc
    logical        :: range_flag
    type(cq_timer) :: tmr_l_tmp1, tmr_l_tmp2
    ! automatic arrays
    real(double), dimension(nspin)      :: pot_here_pcc
    real(double), dimension(size)       :: xc_epsilon, density_wk_tot
    real(double), dimension(size,nspin) :: xc_potential, density_wk

    ! initialise arrays
    pcc_force = zero
    xc_potential = zero
    xc_epsilon = zero

    dcellx_block = rcellx / blocks%ngcellx
    dcelly_block = rcelly / blocks%ngcelly
    dcellz_block = rcellz / blocks%ngcellz

    dcellx_grid = dcellx_block / nx_in_block
    dcelly_grid = dcelly_block / ny_in_block
    dcellz_grid = dcellz_block / nz_in_block
        
    call start_timer (tmr_l_tmp2) 

    do spin = 1, nspin
       density_wk(:,spin) = density(:,spin) + half * density_pcc(:)
    end do
    density_wk_tot = spin_factor * sum(density_wk, 2)

    if (nspin == 1) then ! spin non-polarised calculation
       select case (flag_functional_type)
       case (functional_lda_pz81)
          call get_xc_potential(density_wk_tot, xc_potential(:,1),     &
                                xc_epsilon, xc_energy, size)
       case (functional_lda_gth96)
          call get_GTH_xc_potential(density_wk_tot, xc_potential(:,1), &
                                    xc_epsilon, xc_energy, size)
       case (functional_lda_pw92)
          call get_xc_potential_LDA_PW92(density_wk_tot,               &
                                         xc_potential(:,1),            &
                                         xc_epsilon, xc_energy, size)
       case (functional_gga_pbe96)
          ! Original PBE
          call get_xc_potential_GGA_PBE(density_wk_tot,                &
                                        xc_potential(:,1), xc_epsilon, &
                                        xc_energy, size)
       case (functional_gga_pbe96_rev98) 
          ! PBE with kappa of PRL 80, 890 (1998)
          call get_xc_potential_GGA_PBE(density_wk_tot,                &
                                        xc_potential(:,1), xc_epsilon, &
                                        xc_energy, size)
       case (functional_gga_pbe96_r99)
          ! PBE with form of PRB 59, 7413 (1999)
          call get_xc_potential_GGA_PBE(density_wk_tot,                &
                                        xc_potential(:,1), xc_epsilon, &
                                        xc_energy, size)
       case default
          call get_xc_potential(density_wk_tot, xc_potential(:,1),     &
                                xc_epsilon, xc_energy, size)
       end select
    else
       select case (flag_functional_type)
       case (functional_lsda_pw92)
          call get_xc_potential_LSDA_PW92(density_wk, xc_potential,    &
                                          xc_epsilon, xc_energy, size)
       case default
          call get_xc_potential_LSDA_PW92(density_wk, xc_potential,    &
                                          xc_epsilon, xc_energy, size)
       end select
    end if ! (nspin == 1)
    
    ! This restarts the count for this timer
    call stop_timer(tmr_l_tmp2, TIME_ACCUMULATE_NO)      
    
    call my_barrier()
    
    call start_timer(tmr_l_tmp1,WITH_LEVEL)
    do iblock = 1, domain%groups_on_node ! primary set of blocks
       xblock = (domain%idisp_primx(iblock) + domain%nx_origin - 1) * dcellx_block
       yblock = (domain%idisp_primy(iblock) + domain%ny_origin - 1) * dcelly_block
       zblock = (domain%idisp_primz(iblock) + domain%nz_origin - 1) * dcellz_block
       if (naba_atm(dens)%no_of_part(iblock) > 0) then ! if there are naba atoms
          iatom = 0
          do ipart = 1, naba_atm(dens)%no_of_part(iblock)
             jpart = naba_atm(dens)%list_part(ipart,iblock)
             if (jpart > DCS_parts%mx_gcover) &
                  call cq_abort('set_ps: JPART ERROR ',ipart,jpart)
             ind_part = DCS_parts%lab_cell(jpart)
             do ia = 1, naba_atm(dens)%no_atom_on_part(ipart,iblock)
                iatom = iatom + 1
                ii = naba_atm(dens)%list_atom(iatom,iblock)
                icover = DCS_parts%icover_ibeg(jpart) + ii - 1
                ig_atom = id_glob(parts%icell_beg(ind_part) + ii - 1)
                the_species = species_glob(ig_atom)
                !the_species=species(ig_atom)
                ! for P.C.C. treatment
                if (.not. pseudo(the_species)%flag_pcc) cycle
                if (parts%icell_beg(ind_part) + ii-1 > ni_in_cell) &
                     call cq_abort('set_ps: globID ERROR ', &
                                   ii, parts%icell_beg(ind_part))
                if (icover > DCS_parts%mx_mcover) &
                     call cq_abort('set_ps: icover ERROR ', &
                                   icover, DCS_parts%mx_mcover)
                xatom = DCS_parts%xcover(icover)
                yatom = DCS_parts%ycover(icover)
                zatom = DCS_parts%zcover(icover)
                pcc_cutoff = pseudo(the_species)%chpcc%cutoff
                pcc_cutoff2 = pcc_cutoff * pcc_cutoff
                step_pcc = pseudo(the_species)%chpcc%delta
                ipoint = 0
                do iz = 1, nz_in_block
                   do iy = 1, ny_in_block
                      do ix = 1, nx_in_block
                         ipoint = ipoint + 1
                         igrid = n_pts_in_block*(iblock-1)+ipoint
                         if (igrid > n_my_grid_points) &
                              call cq_abort('get_nonSC_force: igrid error ', &
                                            igrid, n_my_grid_points)
                         do spin = 1, nspin
                            pot_here_pcc(spin) = &
                                 xc_potential(igrid,spin) * grid_point_volume
                         end do
                         dx = dcellx_grid * (ix - 1)
                         dy = dcelly_grid * (iy - 1)
                         dz = dcellz_grid * (iz - 1)
                         rx = xblock + dx - xatom
                         ry = yblock + dy - yatom
                         rz = zblock + dz - zatom
                         r2 = rx * rx + ry * ry + rz * rz
                         if (r2 < pcc_cutoff2) then
                            r_from_i = sqrt(r2)
                            if (r_from_i > very_small) then
                               x_pcc = rx / r_from_i
                               y_pcc = ry / r_from_i
                               z_pcc = rz / r_from_i
                            else
                               x_pcc = zero
                               y_pcc = zero
                               z_pcc = zero
                            end if
                            call dsplint(step_pcc,                        &
                                         pseudo(the_species)%chpcc%f(:),  &
                                         pseudo(the_species)%chpcc%d2(:), &
                                         pseudo(the_species)%chpcc%n,     &
                                         r_from_i, v_pcc, derivative_pcc, &
                                         range_flag)
                            if (range_flag) &
                                 call cq_abort('get_pcc_force: overrun problem')
                            ! the factor of half here is because for
                            ! spin polarised calculations, I have
                            ! assumed contribution from pcc_density is
                            ! exactly half of the total in each spin
                            ! channel.
                            derivative_pcc = half * derivative_pcc
                            fx_pcc = x_pcc * derivative_pcc
                            fy_pcc = y_pcc * derivative_pcc
                            fz_pcc = z_pcc * derivative_pcc
                         else
                            fx_pcc = zero
                            fy_pcc = zero
                            fz_pcc = zero
                         end if
                         do spin = 1, nspin
                            pcc_force(1,ig_atom) =      &
                                 pcc_force(1,ig_atom) + &
                                 spin_factor * fx_pcc * pot_here_pcc(spin)
                            pcc_force(2,ig_atom) =      &
                                 pcc_force(2,ig_atom) + &
                                 spin_factor * fy_pcc * pot_here_pcc(spin)
                            pcc_force(3,ig_atom) =      &
                                 pcc_force(3,ig_atom) + &
                                 spin_factor * fz_pcc * pot_here_pcc(spin)
                         end do ! spin
                      end do !ix
                   end do  !iy
                end do   !iz
             end do ! naba_atoms
          end do ! naba_part
       end if !(naba_atm(dens)%no_of_part(iblock) > 0) !naba atoms?
    end do ! iblock : primary set of blocks
    call stop_print_timer(tmr_l_tmp1, "PCC force - Orbital part", &
                          IPRINT_TIME_THRES3)
    call start_timer(tmr_l_tmp1, WITH_LEVEL)
    call gsum(pcc_force, 3, n_atoms)
    call stop_print_timer(tmr_l_tmp1, "PCC force - Compilation", &
                          IPRINT_TIME_THRES3)
    return    
  end subroutine get_pcc_force
  !*****


! -----------------------------------------------------------
! Subroutine get_dxc_potential
! -----------------------------------------------------------

!!****f* force_module/get_dxc_potential *
!!
!!  NAME 
!!   get_dxc_potential
!!  USAGE
!! 
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent 
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Perdew-Zunger parameterisation of the Ceperley-Alder 
!!   results for a homogeneous electron gas, as described in Phys. Rev. B 23, 5048 (1981), 
!!   with Ceperley-Alder in Phys. Rev. Lett. 45, 566 (1980)
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   09:36, 2003/03/20 dave
!!  MODIFICATION HISTORY
!!   2007/11/16 12:10 dave
!!    Bug fix: sign of ninth*(two*s+r)*rs term in dv_correlation was wrong
!!   2008/03/03 18:34 dave
!!    Removed dsqrt
!!   2011/12/13 L.Tong
!!    Removed third, as it is now defined in numbers module
!!  SOURCE
!!
  subroutine get_dxc_potential(density,dxc_potential,size )

    use datatypes
    use numbers
    use dimens, only: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, only: gsum

    implicit none

    ! Passed variables
    integer size

    real(double) :: density(size), dxc_potential(size)      

    !     Local variables
    integer n
    real(double) :: denominator, e_correlation, &
         e_exchange, ln_rs, vnumerator, &
         rcp_rs, rho, rs, rs_ln_rs, &
         sq_rs, dv_correlation, dv_exchange, dfirst, dsecond
    real(double), parameter :: alpha = -0.45817_double
    real(double), parameter :: beta_1 = 1.0529_double
    real(double), parameter :: beta_2 = 0.3334_double
    real(double), parameter :: gamma = - 0.1423_double 
    real(double), parameter :: p = 0.0311_double
    real(double), parameter :: q = - 0.048_double
    real(double), parameter :: r = 0.0020_double
    real(double), parameter :: s = - 0.0116_double
    real(double), parameter :: ninth = 1.0_double/9.0_double
    real(double), parameter :: sixth = 1.0_double/6.0_double

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n) 
       if (rho>very_small) then ! Find radius of hole
          rcp_rs = ( four_thirds * pi * rho )**(third)
       else
          rcp_rs = zero
       end if
       ! First, the easy part: exchange
       e_exchange = alpha * rcp_rs
       if(rho>very_small) then
          dv_exchange = four*ninth * e_exchange/rho
       else
          dv_exchange = zero
       end if
       if (rcp_rs>zero) then
          rs = one/rcp_rs
       else
          rs = zero
       end if
       sq_rs = sqrt(rs)
       if (rs>=one) then
          denominator = one / (one + beta_1 * sq_rs + beta_2 * rs)
          vnumerator = one + seven_sixths * beta_1 * sq_rs +  &
               four_thirds * beta_2 * rs
          dfirst = (one + beta_1 * sq_rs + beta_2 * rs)*(-seven_thirtysixths*beta_1*sq_rs - four*ninth*beta_2*rs)
          dsecond = -two*vnumerator*(-sixth*beta_1*sq_rs-third*beta_2*rs)
          if(rho>very_small) then
             dv_correlation = gamma * (dfirst+dsecond) * denominator * denominator * denominator / rho
          else
             dv_correlation = zero
          end if
       else if ((rs<one).and.(rs>very_small)) then
          ln_rs = log(rs)
          rs_ln_rs = rs * ln_rs
          if(rho>very_small) then
             ! DRB 2007/11/16 Changed sign of ninth to PLUS to correct error
             dv_correlation = -(third*p+two*ninth*r*rs_ln_rs+ninth*(two*s+r)*rs)/rho
          else
             dv_correlation = zero
          end if
       else 
          dv_correlation = zero
       end if
       ! Both X and C
       dxc_potential(n) = (dv_exchange + dv_correlation)
       ! Just C 
       !dxc_potential(n) = dv_correlation
       ! Just X
       !dxc_potential(n) = dv_exchange
    end do ! do n_my_grid_points
    return
  end subroutine get_dxc_potential
!!***

! -----------------------------------------------------------
! Subroutine get_GTH_dxc_potential
! -----------------------------------------------------------

!!****f* force_module/get_GTH_dxc_potential *
!!
!!  NAME 
!!   get_GTH_dxc_potential
!!  USAGE
!! 
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent 
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Goedecker/Teter/Hutter parameterisation - 
!!   see PRB 54, 1703 (1996)
!!  INPUTS
!! 
!! 
!!  USES
!! 
!!  AUTHOR
!!   D.R.Bowler
!!  CREATION DATE
!!   14:54, 25/03/2003 drb 
!!  MODIFICATION HISTORY
!!   2011/12/13 L.Tong
!!    Removed third, it is now defined in numbers module
!!  SOURCE
!!
  subroutine get_GTH_dxc_potential(density,dxc_potential,size )

    use datatypes
    use numbers
    use dimens, only: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, only: gsum

    implicit none

    ! Passed variables
    integer size

    real(double) :: density(size), dxc_potential(size)      

    !     Local variables
    integer n
    real(double) :: denominator, e_correlation, &
         e_exchange, ln_rs, vnumerator, &
         rcp_rs, rho, rs, rs_ln_rs,t1, t2, dt1, dt2, d2t1, d2t2, &
         sq_rs, dv_correlation, dv_exchange, dfirst, dsecond, drs_dRho, d2rs_dRho2
    real(double), parameter :: a0=0.4581652932831429_double
    real(double), parameter :: a1=2.217058676663745_double
    real(double), parameter :: a2=0.7405551735357053_double
    real(double), parameter :: a3=0.01968227878617998_double
    real(double), parameter :: b1=1.000000000000000_double
    real(double), parameter :: b2=4.504130959426697_double
    real(double), parameter :: b3=1.110667363742916_double
    real(double), parameter :: b4=0.02359291751427506_double    

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n) 
       if (rho>very_small) then ! Find radius of hole
          rcp_rs = ( 4.0_double*third * pi * rho )**(third)
          rs = one/rcp_rs
       else
          rcp_rs = zero
          rs = zero
          rho = zero
       end if
       if(rs>zero) then
          drs_dRho = -rs / (3.0_double * rho)
          d2rs_dRho2 = 4.0_double * rs / (9.0_double * rho * rho)
          t1 = a0 + rs * (a1 + rs * (a2 + rs * a3))
          t2 = rs * (b1 + rs * (b2 + rs * (b3 + rs * b4)))
          dt1 = a1 + rs * (2.0_double * a2 + rs * 3.0_double * a3)
          dt2 = b1 + rs * (2.0_double * b2 + rs * (3.0_double * b3 + rs * 4.0_double * b4))
          d2t1 = 2.0_double * a2 + 6.0_double * a3 * rs
          d2t2 = 2.0_double * b2 + rs * (6.0_double * b3 + rs * 12.0_double * b4)
          dxc_potential(n) = 2.0_double*drs_dRho * (-dt1 / t2 + t1 * dt2 / (t2 * t2)) + &
               rho* &
               (drs_dRho*drs_dRho*(2.0_double*dt1*dt2/(t2*t2)-d2t1/t2-2.0_double*t1*dt2*dt2/(t2*t2*t2)+d2t2*t1/(t2*t2)) + &
               d2rs_dRho2*(-dt1 / t2 + t1 * dt2 / (t2 * t2)))
       else
          dxc_potential(n) = zero
       end if
    end do ! do n_my_grid_points
    return
  end subroutine get_GTH_dxc_potential
!!***


!!****f* H_matrix_module/get_dxc_potential_LDA_PW92 *
!!
!!  NAME
!!   get_dxc_potential_LDA_PW92
!!  USAGE
!!
!!  PURPOSE
!!   Calculates the derivative of the exchange-correlation potential
!!   on the grid within LDA using the Ceperley-Alder
!!   interpolation formula. This is only for non self-consistent
!!   calculations (Harris-Foulkes), for the forces.
!!
!!   Note that this is the Perdew-Wang parameterisation of the Ceperley-Alder
!!   results for a homogeneous electron gas, as described in Phys. Rev. B 45, 13244 (1992),
!!   with Ceperley-Alder in Phys. Rev. Lett. 45, 566 (1980)
!!  INPUTS
!!
!!
!!  USES
!!
!!  AUTHOR
!!   A.S. Torralba
!!  CREATION DATE
!!   30/01/06
!!  MODIFICATION HISTORY
!!   2008/03/03 18:34 dave
!!    Removed dsqrt
!!   2011/10/17 L.Tong
!!    Corrected (changed) 1 to one in log (1 + 1/denominator)
!!   2011/12/13 L.Tong
!     Removed third, it is now defined in numbers module
!!  SOURCE
!!
  subroutine get_dxc_potential_LDA_PW92(density,dxc_potential,size, &
             eclda,declda_drho,d2eclda_drho2)

    use datatypes
    use numbers
    use dimens, only: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points
    use GenComms, only: gsum

    implicit none

    ! Passed variables
    integer :: size

    real(double) :: density(size), dxc_potential(size)
    real(double), optional :: eclda(size)
    real(double), optional :: declda_drho(size)
    real(double), optional :: d2eclda_drho2(size)

    !     Local variables
    integer n
    real(double) :: prefactor, postfactor, denominator, &
                    e_correlation, e_exchange, &
                    rcp_rs, rho, rs, sq_rs, &
                    v_correlation, v_exchange, &
                    delta_prefactor, delta_postfactor, &
                    dv_exchange, dv_correlation, &
                    denominator2, dnumrho_drho, &
                    dden_drho, rho4_3, &
                    dprefactor_drho, d2prefactor_drho2, &
                    dposfactor_drho, d2posfactor_drho2, &
                    dec_drho, d2ec_drho2


    !     From Table I, Phys. Rev. B 45, 13244 (1992), for reference
    real(double), parameter :: alpha  = 1.0421234_double
    real(double), parameter :: alpha1 = 0.21370_double
    real(double), parameter :: beta1  = 7.5957_double
    real(double), parameter :: beta2  = 3.5876_double
    real(double), parameter :: beta3  = 1.6382_double
    real(double), parameter :: beta4  = 0.49294_double
    real(double), parameter :: A      = 0.031091_double

    !     Precalculated constants
    real(double), parameter :: k00 = 1.611991954_double     ! (4*pi/3)**(1/3)
    real(double), parameter :: k01 = -0.458165347_double    ! -3/(2*pi*alpha)
    real(double), parameter :: k02 = -0.062182_double       ! -2*A
    real(double), parameter :: k03 = -0.0132882934_double   ! -2*A*alpha1
    real(double), parameter :: k04 = 0.4723158174_double    ! 2*A*beta1
    real(double), parameter :: k05 = 0.2230841432_double    ! 2*A*beta2
    real(double), parameter :: k06 = 0.1018665524_double    ! 2*A*beta3
    real(double), parameter :: k07 = 0.03065199508_double   ! 2*A*beta4
    real(double), parameter :: k08 = -0.008858862267_double ! 2*k03/3
    real(double), parameter :: k09 = 0.0787193029_double    ! k04/6
    real(double), parameter :: k10 = 0.074361381067_double  ! k05/3
    real(double), parameter :: k11 = 0.0509332762_double    ! k06/2
    real(double), parameter :: k12 = 0.0204346633867_double ! 2*k07/3
    real(double), parameter :: four_ninths = 4.0_double/9.0_double
    real(double), parameter :: minus_four_thirds = -4.0_double/3.0_double
    real(double), parameter :: k13 = 0.0027477997778_double ! (k08-k03)/k00

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n)

       !!!!   EXCHANGE
       if (rho > very_small) then ! Find radius of hole
          rcp_rs = k00 * ( rho**third )
          dv_exchange = four_ninths * k01 * rcp_rs / rho    ! 4*e_exchange/(9*rho)
       else
          rcp_rs = zero
          dv_exchange = zero
       end if

       e_exchange = k01*rcp_rs

       !!!!   CORRELATION
       if (rcp_rs > zero) then
          rs = one/rcp_rs
       else
          rs = zero
       end if
       sq_rs = sqrt(rs)

       prefactor = k02 + k03*rs
       denominator = sq_rs * ( k04 + sq_rs * ( k05 + sq_rs * ( k06 + k07 * sq_rs)))
       if (denominator > zero) then
          postfactor = log (one + one/denominator)
       else
          postfactor = zero
       end if

       ! Return correlation energy if requested
       ! NOTE: This "energy" is not the actual integrand, but the integrand divided by rho
       if(present(eclda)) then
         eclda(n) = prefactor*postfactor
       end if


       ! NOTE: delta_prefactor is actually the derivative of rho*prefactor
       !       delta_postfactor is rho times the derivative of postfactor
       delta_prefactor  = k02 + k08*rs
       if (sq_rs > zero) then
          denominator2 = ( denominator * ( 1 + denominator ) )
          delta_postfactor = sq_rs * ( k09 + sq_rs*(k10 + sq_rs*( k11 + k12 * sq_rs ))) &
                           / denominator2

          dnumrho_drho = -sq_rs *( 7.0*k09/6.0 + sq_rs * ( 4.0*k10/3.0 + sq_rs * ( 3.0*k11/2.0 +sq_rs*5.0*k12/3.0)))
          dden_drho = -sq_rs*(k04/6.0 +sq_rs*(third*k05 + sq_rs*(half*k06 + sq_rs*2.0*k07/3.0)))
       else
          delta_postfactor = 0

          dnumrho_drho = zero
          dden_drho = zero
       end if

       if(rho > very_small) then
          rho4_3 = rho**minus_four_thirds
          dprefactor_drho   = k13*rho4_3
          d2prefactor_drho2 = minus_four_thirds*dprefactor_drho/rho

          dposfactor_drho   = delta_postfactor/rho
          d2posfactor_drho2 = (dnumrho_drho &
                            - delta_postfactor * ( 1 + 2*denominator) * dden_drho)/(denominator2 * rho *rho)
       else
          rho4_3 = zero
          dprefactor_drho   = zero
          d2prefactor_drho2 = zero

          dposfactor_drho   = zero
          d2posfactor_drho2 = zero
       end if

       dec_drho = postfactor*dprefactor_drho + prefactor*dposfactor_drho

       ! Return derivative of correlation energy (see note above) if requested
       if(present(declda_drho)) then
          declda_drho(n) = dec_drho
       end if


       d2ec_drho2 = 2*dposfactor_drho*dprefactor_drho &
                  + postfactor*d2prefactor_drho2 + prefactor*d2posfactor_drho2

       ! Return second derivative of correlation energy (see note above) if requested
       if(present(d2eclda_drho2)) then
          d2eclda_drho2(n) = d2ec_drho2
       end if

       dv_correlation = 2*dec_drho + rho*d2ec_drho2

       dxc_potential(n) = dv_exchange + dv_correlation
    end do ! do n_my_grid_points

    return
  end subroutine get_dxc_potential_LDA_PW92
!!***


! -----------------------------------------------------------
! Subroutine get_dxc_potential_GGA_PBE
! -----------------------------------------------------------

!!****f* H_matrix_module/get_dxc_potential_GGA_PBE *
!!
!!  NAME
!!   get_dxc_potential_GGA_PBE
!!  USAGE
!!
!!  PURPOSE
!!   Calculates the potential needed for the non-self-consistent 
!!   within GGA using the Perdew-Burke-Ernzerhof.
!!
!!   Note that this is the functional described in
!!   Phys. Rev. Lett. 77, 3865 (1996)
!!  INPUTS
!!
!!
!!  USES
!!
!!  AUTHOR
!!   A.S. Torralba
!!  CREATION DATE
!!   31/01/05
!!  MODIFICATION HISTORY
!!   15:54, 27/04/2007 drb 
!!    Changed recip_vector, grad_density and tmp2, tmp3 to (n,3) for speed
!!   2008/11/13 ast
!!    Added new PBE functional types
!!   2011/12/13 L.Tong
!!    Removed third, and eight, they are now defined in numbers module
!!  SOURCE
!!
  subroutine get_dxc_potential_GGA_PBE(density,density_out, dxc_potential, size, flavour )

    use datatypes
    use numbers
    use global_module, only: rcellx, rcelly, rcellz, &
                             functional_gga_pbe96_rev98, functional_gga_pbe96_r99
    use dimens, only: grid_point_volume, one_over_grid_point_volume, &
         n_my_grid_points, n_grid_x, n_grid_y, n_grid_z
    use GenComms, only: gsum, myid
    use energy, only: delta_E_xc
    use fft_module, only: fft3, recip_vector
    use H_matrix_module, only: build_gradient, get_xc_potential_LDA_PW92

    implicit none

    ! Passed variables
    integer size
    real(double) :: density(size)
    real(double) :: density_out(size)
    real(double) :: dxc_potential(size)
    integer, optional :: flavour

    !     Local variables
    integer n, i
    integer selector

    real(double) :: grad_density(size), grad_density_xyz(size,3)
    real(double) :: rho, grad_rho, rho1_3, rho1_6
    real(double) :: e_exchange
    real(double) :: xc_energy_lda_total, dxc_potential_lda(size), &
                    eclda(size), declda_drho(size), d2eclda_drho2(size)
    real(double) :: de_dgrad(size)
    real(double) :: s, s2, factor0, factor1, denominator0, denominator0_2
    real(double) :: d2e_drho2, d2e_dgrad2(size), d2e_dgrad_drho(size)
    real(double) :: dden0_drho, df0f1_drho, ds_grad, dden0_dgrad, ds_dgrad, df1_dgrad
    real(double) :: diff_rho(size)
    complex(double_cplx) :: tmp1(size), tmp2(size,3)
    real(double) :: tmp3(size,3), tmp_factor

    real(double) :: a, a2, t, t2, t3, t4, num1, den1, den1_2, fl
    real(double) :: factor_exp, factor_exp2, factor_exp3
    real(double) :: dt_drho, da_drho, dnum1_drho, dden1_drho, dfl_drho, dec_drho
    real(double) :: dt_dgrad, dnum1_dgrad, dden1_dgrad, dfl_dgrad
    real(double) :: d2t_drho2, d2a_drho2, d2num1_drho2, d2den1_drho2, d2fl_drho2
    real(double) :: d2num1_dgrad2, d2den1_dgrad2, d2fl_dgrad2
    real(double) :: d2t_drho_dgrad, d2num1_drho_dgrad, d2den1_drho_dgrad
    real(double) :: d2fl_drho_dgrad

    real(double) :: kappa, mu_kappa
   
    !     From Phys. Rev. Lett. 77, 3865 (1996)
    real(double), parameter :: mu = 0.21951_double
    real(double), parameter :: beta = 0.066725_double
    real(double), parameter :: gamma = 0.031091_double
    real(double), parameter :: kappa_ori = 0.804_double

    !     From Phys. Rev. Lett. 80, 890 (1998)
    real(double), parameter :: kappa_alt = 1.245_double

    !     Precalculated constants
    real(double), parameter :: mu_kappa_ori = 0.27302_double     ! mu/kappa_ori
    real(double), parameter :: mu_kappa_alt = 0.17631_double     ! mu/kappa_alt
    real(double), parameter :: beta_gamma = 2.146119_double      ! beta/gamma
    real(double), parameter :: beta_X_gamma = 0.002074546_double ! beta*gamma
    real(double), parameter :: k01 = 0.16162045967_double        ! 1/(2*(3*pi*pi)**(1/3))
    real(double), parameter :: k02 = -0.16212105381_double       ! -3*mu*((4*pi/3)**3)/(2*pi*alpha)
                                                                 ! = mu*k00*k01(LDA_PW92)=mu*k04
    real(double), parameter :: k03 = 1.98468639_double           ! ((4/pi)*(3*pi*pi)**(1/3))**(1/2)
    real(double), parameter :: k04 = -0.738558852965_double      ! -3*((4*pi/3)**3)/(2*pi*alpha) = k00*k01 in LDA_PW92
    real(double), parameter :: k05 = 0.05240415_double           ! -2*k01*k02
    real(double), parameter :: eight_thirds = 8.0_double / 3.0_double

    !      Selector options
    integer, parameter :: fx_original    = 1                     ! Used in PBE and revPBE
    integer, parameter :: fx_alternative = 2                     ! Used in RPBE

    ! Choose between PBE or revPBE parameters
    if(PRESENT(flavour)) then
      if(flavour==functional_gga_pbe96_rev98) then
        kappa=kappa_alt
        mu_kappa=mu_kappa_alt
      else
        kappa=kappa_ori
        mu_kappa=mu_kappa_ori
      end if
    else
      kappa=kappa_ori
      mu_kappa=mu_kappa_ori
    end if

!*ast* AT PRESENT IGNORED
    ! Choose functional form
    if(PRESENT(flavour)) then
      if(flavour==functional_gga_pbe96_r99) then
        selector=fx_alternative
      else
        selector=fx_original
      end if
    else
      selector=fx_original
    end if

!*ast* AT PRESENT, NOT IMPLEMENTED
if(selector == fx_alternative) then
  print *,"!!!!!!!!WARNING!!!!!!!!!!!"
  print *,"WARNING: TO DO !!!!!!!!! RPBE NSC Forces NOT IMPLEMENTED YET. The values will be for standard PBE"
  print *,"!!!!!!!!WARNING!!!!!!!!!!!"
end if

    ! Build the gradient of the density
    call build_gradient (density, grad_density, grad_density_xyz, size)

    ! Get the LDA part of the functional

    call get_dxc_potential_LDA_PW92(density, dxc_potential_lda, size, &
                                    eclda, declda_drho, d2eclda_drho2)

    do n=1,n_my_grid_points ! loop over grid pts and store potl on each
       rho = density(n)
       grad_rho = grad_density(n)

       diff_rho(n) = density(n) - density_out(n)

       !!!!   EXCHANGE

       !!   Energy factors

       if (rho > very_small) then
          rho1_3 = rho ** third
          rho1_6 = sqrt (rho1_3)
          s = k01 * grad_rho / (rho ** four_thirds)
          s2 = s * s
          denominator0 = one / (one + mu_kappa * s2)
          denominator0_2 = denominator0 * denominator0
          factor0 = k02 * rho1_3
          factor1 = s2 * denominator0
          ! NOTE: This doesn't look like in Phys. Rev. Lett. 77:18, 3865 (1996)
          !       because the 1 in Fx, has been multiplied by Ex-LDA and is implicit
          !       in xc_energy_lda(n), in the total energy below
          e_exchange = factor0 * factor1
       else
          s  = 0.0_double              
          s2 = 0.0_double
          denominator0 = 0.0_double
          denominator0_2 = 0.0_double 
          factor0 = 0.0_double
          factor1 = 0.0_double
          e_exchange = zero
       end if

       !!   Second derivative of Ex wrt rho
       if (rho > very_small) then
          dden0_drho = mu_kappa * eight_thirds * denominator0_2 * s2 /rho
          df0f1_drho = third * e_exchange * (one - eight * denominator0) / rho
          d2e_drho2 = four_thirds * (df0f1_drho * (one - two * denominator0) &
                    - two * e_exchange * dden0_drho)
       else
          d2e_drho2 = 0.0_double
       end if

       !!   Second derivative of Ex wrt grad
       ds_dgrad = 0.0_double
       if(rho > very_small) ds_dgrad = k01 * rho**(-four_thirds)
       dden0_dgrad = -two * mu_kappa * denominator0_2 * s * ds_dgrad 

       d2e_dgrad2(n) = two * rho * factor0 * ds_dgrad * (ds_dgrad * denominator0_2 &
                     + two * s * denominator0 * dden0_dgrad)

       !!   Second derivative of Ex wrt grad and rho
       df1_dgrad = two * s * denominator0_2 * ds_dgrad

       d2e_dgrad_drho(n) = (four_thirds) * factor0 &
                         * (df1_dgrad * (one - two * denominator0) &
                         - two * factor1 * dden0_dgrad)


       !!   First derivative wrt gradient
       de_dgrad(n) = rho * factor0 * df1_dgrad


       !!!!   CORRELATION

       !!   Energy terms
       factor_exp = exp(-eclda(n)/gamma)
       a = factor_exp - one
       if(a > very_small) then
         a = beta_gamma / a
       else 
         a = beta_gamma * BIG
       end if
       a2 = a * a

       if(rho > very_small) then       
         t = grad_rho/(two*k03*(rho**seven_sixths))
       else
         t = 0.0_double
       end if
       t2 = t * t
       t3 = t2 * t
       t4 = t2 * t2
       num1 = one + a*t2;
       den1 = num1 + a2*t4;
       den1_2 = den1*den1;
       if(den1 > very_small) then
         fl = one + beta_gamma * t2 * num1 / den1;
       else
         fl = one
       end if


       !!   First derivative wrt rho
       
       if(rho > very_small) then 
         dt_drho = -seven_sixths*t/rho
       else
         dt_drho = 0.0_double
       end if
    !TM 2007_10_18  
    ! eclda(n) = 0 -> factor_exp = one -> zero**(-2) !!!
    !ORI   factor_exp2 = (factor_exp - one)**(-two)
     if(abs(factor_exp-one) > very_small) then
       factor_exp2 = one/(factor_exp - one)
       factor_exp2 = factor_exp2**2
     else
       factor_exp2 = 0.0_double
     end if

       da_drho = beta_gamma * factor_exp * factor_exp2 * declda_drho(n)/gamma
       dnum1_drho = da_drho * t2 + two*a*t*dt_drho
       dden1_drho = dnum1_drho + two*a*t4*da_drho + four*a2*t3*dt_drho
       if(den1 > very_small) then
         dfl_drho = beta_gamma*((two*t*num1*dt_drho + t2*dnum1_drho)/den1 - t2*num1*dden1_drho/den1_2)
       else
         dfl_drho = 0.0_double
       end if
       dec_drho = gamma * (log(fl) + rho * dfl_drho / fl)

       !!   Second derivative with respect to rho

       if(rho > very_small) then
         d2t_drho2 = seven_sixths*(t/(rho*rho) - dt_drho/rho)
       else
         d2t_drho2 = 0.0_double
       end if
       factor_exp3 = factor_exp * factor_exp2
      if(abs(factor_exp-one) > very_small) then
       d2a_drho2 = (beta_gamma/gamma)*( ( ( (two * factor_exp / (factor_exp - one)) - one )&
                 * factor_exp3 * declda_drho(n)**2) /gamma &
                 + factor_exp3 * d2eclda_drho2(n))
      else
       d2a_drho2 = zero
      end if

       d2num1_drho2 = d2a_drho2*t2 + four*t*da_drho*dt_drho &
                    + two*a*((dt_drho**2) + t*d2t_drho2)
       d2den1_drho2 = d2num1_drho2 + two*((da_drho*t2)**2) &
                    + two*a*d2a_drho2*t4 &
                    + 16.0_double*a*t3*da_drho*dt_drho &
                    + 12.0_double*((a*t*dt_drho)**2) &
                    + four*a2*t3*d2t_drho2
       if(den1 > very_small) then
         d2fl_drho2 = beta_gamma*(two*num1*(dt_drho**2) &
                    + t*(four*(dnum1_drho*dt_drho &
                    - num1*dden1_drho*dt_drho/den1) &
                    + two*num1*d2t_drho2) &
                    + t2*(d2num1_drho2 &
                    + two*(num1*((dden1_drho/den1)**2) &
                    - dnum1_drho*dden1_drho/den1) &
                    - num1*d2den1_drho2/den1))/den1
       else
         d2fl_drho2 = 0.0_double
       end if
       d2e_drho2 = d2e_drho2 + gamma*(two*dfl_drho/fl - rho*((dfl_drho/fl)**2) + rho*d2fl_drho2/fl);


       !!   First derivative with respect to grad

       if(rho > very_small) then 
         dt_dgrad = one/(two*k03*(rho**seven_sixths))
       else
         dt_dgrad = 0.0_double
       end if
       dnum1_dgrad = two*a*t*dt_dgrad
       dden1_dgrad = two*a*t*dt_dgrad + four*a2*t3*dt_dgrad
       if(den1 > very_small) then
          dfl_dgrad = two*beta_gamma*t*num1*dt_dgrad/den1 + beta_gamma*t2*dnum1_dgrad/den1  &
                 - beta_gamma*t2*num1*dden1_dgrad/den1_2
       else
          dfl_dgrad = 0.0_double
       end if
       de_dgrad(n) = de_dgrad(n) + gamma * rho * dfl_dgrad / fl
 
 
       !!   Second derivative with respect to grad
 
       d2num1_dgrad2 = two*a*(dt_dgrad**2)
       d2den1_dgrad2 = d2num1_dgrad2 + 12.0*((a*t*dt_dgrad)**2)
       if(den1 > very_small) then
        d2fl_dgrad2 = beta_gamma*(two*num1*(dt_dgrad**2)/den1 &
                    + four*t*dnum1_dgrad*dt_dgrad/den1 &
                    - two*t*num1*dden1_dgrad*dt_dgrad/den1_2 &
                    + t2*d2num1_dgrad2/den1 &
                    - t2*dden1_dgrad*dnum1_dgrad/den1_2 &
                    - two*t*num1*dden1_dgrad*dt_dgrad/den1_2 &
                    - t2*dnum1_dgrad*dden1_dgrad/den1_2 &
                    + two*t2*num1*(dden1_dgrad**2)/(den1_2*den1) &
                    - t2*num1*d2den1_dgrad2/den1_2)
       else
        d2fl_dgrad2 = zero
       end if
       d2e_dgrad2(n) = d2e_dgrad2(n) + gamma*rho*(d2fl_dgrad2/fl - (dfl_dgrad**2)/(fl*fl))
 
       !!   Second derivative with respect to rho and grad

       ! if((grad_rho > very_small ) .or. (rho > very_small)) then  ! Changed by TM 19Oct2007
       if((grad_rho > very_small ) .and. (rho > very_small)) then 
         d2t_drho_dgrad = -seven_sixths*t/(grad_rho*rho)
       else
         d2t_drho_dgrad = 0.0_double
       end if      
       d2num1_drho_dgrad = two*(t*da_drho*dt_dgrad + a*dt_drho*dt_dgrad + a*t*d2t_drho_dgrad)
       d2den1_drho_dgrad = d2num1_drho_dgrad + 8.0*a*t3*da_drho*dt_dgrad + 12.0*a2*t2*dt_drho*dt_dgrad &
                         + four*a2*t3*d2t_drho_dgrad
       if(den1 > very_small) then
          d2fl_drho_dgrad = beta_gamma*(two*(dt_drho*dt_dgrad*num1 &
                          + t*(dnum1_drho*dt_dgrad &
                          + num1*(d2t_drho_dgrad &
                          - (dden1_drho*dt_dgrad &
                          + dt_drho*dden1_dgrad)/den1) &
                          + dnum1_dgrad*dt_drho &
                         + t*num1*dden1_drho*dden1_dgrad/den1_2)) &
                         + t2*(d2num1_drho_dgrad &
                         - (dnum1_dgrad*dden1_drho &
                         + dnum1_drho*dden1_dgrad &
                         + num1*d2den1_drho_dgrad)/den1))/den1
       else
         d2fl_drho_dgrad = 0.0_double
       end if
        d2e_dgrad_drho(n) = d2e_dgrad_drho(n) + gamma*(dfl_dgrad + rho*(d2fl_drho_dgrad - dfl_drho*dfl_dgrad/fl))/fl
 
 
       !!   Add term L1 to the potential
       dxc_potential(n) = dxc_potential(n) &
                        + diff_rho(n) * (d2e_drho2 + dxc_potential_lda(n))

    end do ! do n_my_grid_points


    ! Fourier transform the difference of densities
     tmp1(:)=cmplx(zero,zero,double_cplx)  !TM
    call fft3(diff_rho, tmp1, size, -1)

    !do n=1, n_my_grid_points  ! debugged 25Oct2007 TM
    do n=1, size        
       ! Product by reciprocal vector stored for later use
       tmp2(n,1) = -minus_i*recip_vector(n,1)*tmp1(n)
       tmp2(n,2) = -minus_i*recip_vector(n,2)*tmp1(n)
       tmp2(n,3) = -minus_i*recip_vector(n,3)*tmp1(n)
    end do

    ! Fourier transform the vector back to the grid
    call fft3(tmp3(:,1), tmp2(:,1), size, 1)
    call fft3(tmp3(:,2), tmp2(:,2), size, 1)
    call fft3(tmp3(:,3), tmp2(:,3), size, 1)

    ! Add term L3 to potential
    do n=1, n_my_grid_points
       do i=1,3 
          if(grad_density(n) > very_small) then
            dxc_potential(n) = dxc_potential(n) + (tmp3(n,i) &
                                                * d2e_dgrad_drho(n) &
                                                * grad_density_xyz(n,i) )/grad_density(n)
          end if
       end do
    end do

    ! Term L4
    do n=1, n_my_grid_points
       if(grad_density(n) > very_small) then
         tmp_factor =(tmp3(n,1) * grad_density_xyz(n,1) &
                    + tmp3(n,2) * grad_density_xyz(n,2) &
                    + tmp3(n,3) * grad_density_xyz(n,3)) &
                    * (d2e_dgrad2(n) &
                    - de_dgrad(n)/grad_density(n) ) / (grad_density(n)*grad_density(n))
       else
         tmp_factor = zero
       end if
       ! Reuse tmp3
       do i=1,3
          if(grad_density(n) > very_small) then
            tmp3(n,i) = tmp_factor * grad_density_xyz(n,i) &
                      + de_dgrad(n) * tmp3(n,i)/grad_density(n)
          else
            tmp3(n,i) = zero
          end if
       end do
    end do

    ! Terms L2 and L5 (using L4)
    do n=1, n_my_grid_points
       do i=1,3
          if(grad_density(n) > very_small) then
            tmp3(n,i) = tmp3(n,i) &
                      + diff_rho(n) * d2e_dgrad_drho(n)* grad_density_xyz(n,i) &
                      / grad_density(n)
          else
            tmp3(n,i) = zero
          end if
       end do
    end do

    tmp2(:,:) = cmplx(zero,zero,double_cplx) ! 25Oct2007 TM
    call fft3(tmp3(:,1), tmp2(:,1), size, -1)
    call fft3(tmp3(:,2), tmp2(:,2), size, -1)
    call fft3(tmp3(:,3), tmp2(:,3), size, -1)

    !do n=1, n_my_grid_points  ! debugged 25Oct2007 TM
    do n=1, size
       ! Product by reciprocal vector stored for later use
       tmp1(n) = -minus_i &
               *(recip_vector(n,1)*tmp2(n,1) &
               + recip_vector(n,2)*tmp2(n,2) &
               + recip_vector(n,3)*tmp2(n,3))
    end do

    ! Use first component of tmp3 to store final vector
    call fft3(tmp3(:,1), tmp1, size, 1)    

    do n=1, n_my_grid_points
       dxc_potential(n) = dxc_potential(n) - tmp3(n,1)
    end do

    return
  end subroutine get_dxc_potential_GGA_PBE
!!***


  !!****f* force_module/get_dxc_potential_LSDA_PW92
  !! PURPOSE
  !!   Calculates the derivative of the exchange-correlation potential
  !!   on the grid within LSDA using the Ceperley-Alder interpolation
  !!   formula. This is only for non self-consistent calcuations
  !!   (Harris-Foulkes), for the forces.
  !!   
  !!   The functional is given by Phys. Rev. B 45, 13244
  !! INPUTS
  !! OUTPUT
  !! RETURN VALUE
  !! AUTHOR
  !!   L.Tong
  !! CREATION DATE 
  !!   2011/10/18
  !! MODIFICATION HISTORY
  !!   2012/03/26 L.Tong
  !!   - Changed spin implementation
  !!   - density is now array of (maxngrid,nspin)
  !!   - dxc_potential_ddensity is now array of
  !!   - (maxngrid,nspin,nspin), so
  !!     dxc_potential_ddensity(n,spin1,spin2) corresponds to
  !!     dVxc(spin1) / drho(spin2) at grid point n.
  !! SOURCE
  !!
  subroutine get_dxc_potential_LSDA_PW92 (density,                &
                                          dxc_potential_ddensity, &
                                          size)
    use datatypes
    use numbers
    use dimens,        only: grid_point_volume,          &
                             one_over_grid_point_volume, &
                             n_my_grid_points
    use GenComms,      only: gsum
    use global_module, only: nspin, spin_factor

    implicit none
    
    ! passed variables
    integer :: size
    real(double), dimension(:,:)   :: density
    real(double), dimension(:,:,:) :: dxc_potential_ddensity
    
    ! local variables
    integer      :: n, spin, spin_2
    real(double) :: rho_tot, rs, rcp_rs, zeta, sq_rs, Q0, Q0p, Q1,     &
                    Q1p, Q1pp, e_c0, e_c1, malpha_c, f, de_c0_drs,     &
                    de_c1_drs, dmalpha_c_drs, df_dzeta, d2e_c0_drs2,   &
                    d2e_c1_drs2, d2malpha_c_drs2, d2f_dzeta2,          &
                    de_c_drs, de_c_dzeta, d2e_c_drs2, d2e_c_drs_dzeta, &
                    d2e_c_dzeta2, d2malpha_drs, df2_dzeta2, factor
    real(double), dimension(nspin)       :: rho, drs_drho, dzeta_drho
    real(double), dimension(nspin,nspin) :: dVx_drho, dVc_drho
    
    ! tabulated parameters
    real(double) :: alpha1, beta1, beta2, beta3, beta4, p, A

    ! precalculated parameters
    real(double), parameter :: k00 =  1.611991954_double ! (4*pi/3)**(1/3)
    real(double), parameter :: k01 = -0.413566994_double ! -(2/pi)**(1/3)/3**(2/3)
    real(double), parameter :: K02 =  1.923661051_double ! 1 / (2**(4/3)-2)
    real(double), parameter :: K03 =  0.584822362_double ! 1 / f''(0)

    ! loop over grid points
    do n = 1, n_my_grid_points
       rho_tot = zero
       do spin = 1, nspin
          rho(spin) = density(n,spin)
          rho_tot = rho_tot + spin_factor * rho(spin)
       end do
       if (rho_tot > very_small) then
          rcp_rs = k00 * rho_tot**third
          zeta = (rho(1) - rho(nspin)) / rho_tot
       else
          rcp_rs = zero
          zeta = zero
       end if

       ! exchange (worked out from Mathematica)
       do spin = 1, nspin
          if (rho(spin) > very_small) then
             dVx_drho(spin,spin) = k01 / ((rho(spin))**two_thirds)
          else
             dVx_drho(spin,spin) = zero
          end if
       end do
       if (nspin == 2) then
          dVx_drho(1,2) = zero ! dVx_drho(1,2) = dVx_up_drho_dn
          dVx_drho(2,1) = zero ! dVx_drho(2,1) = dVx_dn_drho_up
       end if

       ! correlation
       if (rcp_rs > very_small) then
          rs = one / rcp_rs
       else
          rs = zero
       end if
       sq_rs = sqrt(rs)

       ! e_c0 and de_c0_drs
       ! from table 1 of Phys. Rev. B 45, 13244
       A = 0.031091_double
       alpha1 = 0.21370_double
       beta1 = 7.5957_double
       beta2 = 3.5876_double
       beta3 = 1.6382_double
       beta4 = 0.49294_double
       p = one
        
       Q0 = -two * A * (one + alpha1 * rs)
       Q1 = two * A * (beta1 * sq_rs + beta2 * rs + beta3 * sq_rs**three + &
            beta4 * rs**(p + one))
       Q0p = -two * A * alpha1
       if (sq_rs > very_small) then
          Q1p = A * (beta1 / sq_rs + two * beta2 + three * beta3 * &
               sq_rs + two * (p + one) * beta4 * rs**p)
          Q1pp = half * A * (-beta1 / (sq_rs**three) + three * beta3 /&
               sq_rs + eight * beta4)
       else
          Q1p = zero
          Q1pp = zero
       end if
       
       if (Q1 > very_small) then
          e_c0 = Q0 * log (one + one / Q1)
          de_c0_drs = Q0p * log (one + one / Q1) - (Q0 * Q1p) / (Q1 * &
               (Q1 + one))
          d2e_c0_drs2 = - (two * Q0p * Q1p + Q0 * Q1pp) / (Q1 * (Q1 + &
               one)) + Q1p * (two * Q1 + one) * Q0 * Q1p / ((Q1 * (Q1 &
               + one))**two)
       else
          e_c0 = zero
          de_c0_drs = zero
          d2e_c0_drs2 = zero
       end if

       ! e_c1 and de_c1_drs
       ! from table 1 of Phys. Rev. B 45, 13244
       A = 0.015545_double
       alpha1 = 0.20548_double
       beta1 = 14.1189_double
       beta2 = 6.1977_double
       beta3 = 3.3662_double
       beta4 = 0.62517_double
       p = one

       Q0 = -two * A * (one + alpha1 * rs)
       Q1 = two * A * (beta1 * sq_rs + beta2 * rs + beta3 * sq_rs**three + &
            beta4 * rs**(p + one))
       Q0p = -two * A * alpha1
       if (sq_rs > very_small) then
          Q1p = A * (beta1 / sq_rs + two * beta2 + three * beta3 * &
               sq_rs + two * (p + one) * beta4 * rs**p)
          Q1pp = half * A * (-beta1 / (sq_rs**three) + three * beta3 /&
               sq_rs + eight * beta4)
       else
          Q1p = zero
          Q1pp = zero
       end if
       
       if (Q1 > very_small) then
          e_c1 = Q0 * log (one + one / Q1)
          de_c1_drs = Q0p * log (one + one / Q1) - (Q0 * Q1p) / (Q1 * &
               (Q1 + one))
          d2e_c1_drs2 = - (two * Q0p * Q1p + Q0 * Q1pp) / (Q1 * (Q1 + &
               one)) + Q1p * (two * Q1 + one) * Q0 * Q1p / ((Q1 * (Q1 &
               + one))**two)
       else
          e_c1 = zero
          de_c1_drs = zero
          d2e_c1_drs2 = zero
       end if

       ! malpha_c and dmalpha_c_drs
       ! from table 1 of Phys. Rev. B 45, 13244
       A = 0.016887_double
       alpha1 = 0.11125_double
       beta1 = 10.357_double
       beta2 = 3.6231_double
       beta3 = 0.88026_double
       beta4 = 0.49671_double
       p = one

       Q0 = - two * A * (one + alpha1 * rs)
       Q1 = two * A * (beta1 * sq_rs + beta2 * rs + beta3 * sq_rs**three + &
            beta4 * rs**(p + one))
       Q0p = -two * A * alpha1
       if (sq_rs > very_small) then
          Q1p = A * (beta1 / sq_rs + two * beta2 + three * beta3 * &
               sq_rs + two * (p + one) * beta4 * rs**p)
          Q1pp = half * A * (-beta1 / (sq_rs**three) + three * beta3 /&
               sq_rs + eight * beta4)
       else
          Q1p = zero
          Q1pp = zero
       end if

       if (Q1 > very_small) then
          malpha_c = Q0 * log (one + one / Q1)
          dmalpha_c_drs = -two * A * alpha1 * log (one + one / Q1) - &
               (Q0 * Q1p) / (Q1 * (Q1 + one))
          d2malpha_c_drs2 = - (two * Q0p * Q1p + Q0 * Q1pp) / (Q1 * &
               (Q1 + one)) + Q1p * (two * Q1 + one) * Q0 * Q1p / ((Q1 &
               * (Q1 + one))**two)
       else
          malpha_c = zero
          dmalpha_c_drs = zero
          d2malpha_c_drs2 = zero
       end if
        
       ! f and df_dzeta
       f = K02 * ((one + zeta)**four_thirds + (one - zeta)**four_thirds - two)
       df_dzeta = four_thirds * K02 * ((one + zeta)**one_third &
            - (one - zeta)**one_third)
       df2_dzeta2 = one_third * four_thirds * K02 * &
            ((one + zeta)**(-two_thirds) + (one - zeta)**(-two_thirds))

       ! drs_drho
       do spin = 1, nspin
          if (rho(spin) > very_small) then
             drs_drho(spin) = - third * rs / rho_tot
             dzeta_drho(spin) = ((-one)**(spin+1) - zeta) / rho_tot
          else
             drs_drho(spin) = zero
             dzeta_drho(spin) = zero
          end if
       end do

       ! first order derivatives
       de_c_drs = de_c0_drs * (one - f * zeta**4) + de_c1_drs * f * &
            zeta**4 + d2malpha_drs * K03 * f * (zeta**4 - one)
       de_c_dzeta = four * zeta**3 * f * (e_c1 - e_c0 + K03 * &
            malpha_c) + df_dzeta * (zeta**4 * e_c1 - zeta**4 * e_c0 + &
            (zeta**4 - one) * K03 * malpha_c)

       ! second order derivatives
       ! d2e_c_drs2
       d2e_c_drs2 = d2e_c0_drs2 * (one - f * zeta**4) + d2e_c1_drs2 * &
            f * zeta**4 + d2malpha_c_drs2 * K03 * f * (zeta**4 - one)
       
       ! d2e_c_drs_dzeta
       d2e_c_drs_dzeta = four * zeta**3 * f * (de_c1_drs - de_c0_drs +&
            K03 * dmalpha_c_drs) + df_dzeta * (zeta **4 * de_c1_drs - &
            zeta**4 * de_c0_drs + (zeta**4 - one) * K03 * &
            dmalpha_c_drs)

       ! d2e_c_dzeta2
       d2e_c_dzeta2 = (twelve * zeta * zeta * f + eight * zeta**3 * &
            df_dzeta) * (e_c1 - e_c0 + K03 * malpha_c) + d2f_dzeta2 * &
            (zeta**4 * e_c1 - zeta**4 * e_c0 + (zeta**4 - one) * K03 *&
            malpha_c)

       ! finally get the derivatives of the correlation potentials
       do spin = 1, nspin
          do spin_2 = 1, nspin
             factor = zeta + (-one)**spin
             dVc_drho(spin,spin_2) = &
                  (two_thirds * de_c_drs - &
                   one_third * rs * d2e_c_drs2 - &
                   factor * d2e_c_drs_dzeta) * &
                  drs_drho(spin_2) - &
                  (one_third * rs * d2e_c_drs_dzeta + &
                   factor * d2e_c_dzeta2) * &
                  dzeta_drho(spin_2)
          end do
       end do

       ! dVc_drho(1,1) = (two_thirds * de_c_drs - one_third * rs * &
       !      d2e_c_drs2 - (zeta - one) * d2e_c_drs_dzeta) * &
       !      drs_drho_up - (one_third * rs * d2e_c_drs_dzeta + (zeta - &
       !      one) * d2e_c_dzeta2) * dzeta_drho_up
       
       ! dVc_up_drho_dn = (two_thirds * de_c_drs - one_third * rs * &
       !      d2e_c_drs2 - (zeta - one) * d2e_c_drs_dzeta) * &
       !      drs_drho_dn - (one_third * rs * d2e_c_drs_dzeta + (zeta - &
       !      one) * d2e_c_dzeta2) * dzeta_drho_dn

       ! dVc_dn_drho_up = (two_thirds * de_c_drs - one_third * rs * &
       !      d2e_c_drs2 - (zeta + one) * d2e_c_drs_dzeta) * &
       !      drs_drho_up - (one_third * rs * d2e_c_drs_dzeta + (zeta + &
       !      one) * d2e_c_dzeta2) * dzeta_drho_up

       ! dVc_dn_drho_dn = (two_thirds * de_c_drs - one_third * rs * &
       !      d2e_c_drs2 - (zeta + one) * d2e_c_drs_dzeta) * &
       !      drs_drho_dn - (one_third * rs * d2e_c_drs_dzeta + (zeta + &
       !      one) * d2e_c_dzeta2) * dzeta_drho_dn

       ! collect things together
       do spin = 1, nspin
          do spin_2 = 1, nspin
             dxc_potential_ddensity(n,spin,spin_2) = &
                  dVx_drho(spin,spin_2) + dVc_drho(spin,spin_2)
          end do
       end do
              
    end do ! n = 1, n_my_grid_points

    return
  end subroutine get_dxc_potential_LSDA_PW92
  !!*****

end module force_module
